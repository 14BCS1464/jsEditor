[
  {
    "id": 1,
    "question": "What is the order of the console output?",
    "code": "console.log('start');\nsetTimeout(() => console.log('timeout'), 0);\nPromise.resolve().then(() => console.log('promise'));\nconsole.log('end');",
    "options": [
      "start, end, timeout, promise",
      "start, end, promise, timeout",
      "start, promise, end, timeout",
      "start, timeout, end, promise"
    ],
    "answer": 1,
   "explain": "Detailed Explanation (Three Key Points)\n\n1. Synchronous Code Runs First (Call Stack)\nconsole.log('start') runs immediately.\nThen setTimeout(...) is registered as a macrotask in the callback queue.\nPromise.resolve().then(...) schedules a microtask in the microtask queue.\nFinally, console.log('end') executes, completing all synchronous code.\n\n2. Microtasks (Promises) Run Next\nAfter the main script finishes, the microtask queue is processed before any macrotasks.\nSo, console.log('promise') executes next.\n\n3. Macrotasks (setTimeout) Run Last\nOnce the microtask queue is empty, the event loop picks the first macrotask from the callback queue.\nThatâ€™s the setTimeout callback, so console.log('timeout') runs last.\n\nFinal Execution Order: start â†’ end â†’ promise â†’ timeout",

    "difficulty": "easy"
  },  
  {
    "id": 2,
    "question": "What gets logged and why?",
    "code": "console.log('A');\nsetTimeout(() => console.log('B'), 0);\nnew Promise(resolve => { console.log('C'); resolve(); }).then(() => console.log('D'));\nconsole.log('E');",
    "options": [
      "A, C, E, D, B",
      "A, C, D, E, B",
      "A, E, C, D, B",
      "A, C, E, B, D"
    ],
    "answer": 0,
    "explain": "ðŸ§  Detailed Explanation (Three Key Points)\n\n1).  Synchronous Code Runs First (Call Stack)\n- `console.log('A')` executes first.\n- The `setTimeout` callback is registered as a macrotask.\n- The Promise executor function runs immediately (synchronous), so it logs `'C'` and resolves.\n- Finally, `console.log('E')` runs before moving to async tasks.\n\n2).  Microtasks Run Next (Promise .then)\n- After the main synchronous stack finishes, the microtask queue runs.\n- The `.then()` callback logs `'D'` next.\n\n3).  Macrotasks Run Last (setTimeout)\n- Once all microtasks are done, the event loop executes macrotasks.\n- The `setTimeout` callback logs `'B'` last.\n\nðŸ§¾ Final Order: A â†’ C â†’ E â†’ D â†’ B",
    "difficulty": "medium"
  },
  {
    "id": 3,
    "question": "What is the output order here?",
    "code": "console.log('1');\nsetTimeout(() => console.log('2'), 0);\nPromise.resolve().then(() => setTimeout(() => console.log('3'), 0));\nPromise.resolve().then(() => console.log('4'));\nconsole.log('5');",
    "options": [
      "1,5,4,2,3",
      "1,5,4,3,2",
      "1,4,5,2,3",
      "1,5,2,4,3"
    ],
    "answer": 0,
    "explain": "ðŸ§  Detailed Explanation (Three Key Points)\n\n1).  Synchronous Code Runs First\n- `console.log('1')` runs immediately.\n- `setTimeout(() => console.log('2'))` is queued as a macrotask.\n- Two Promises are created and queued as microtasks.\n- `console.log('5')` runs at the end of synchronous execution.\n\n2).  Microtasks Execute Next\n- The first microtask schedules another macrotask for `'3'` using `setTimeout`.\n- The second microtask logs `'4'` immediately.\n\n3).  Macrotasks Execute in Order Queued\n- `'2'` (first `setTimeout`) runs before `'3'` (scheduled later by the microtask).\n\nðŸ§¾ Final Order: 1 â†’ 5 â†’ 4 â†’ 2 â†’ 3",
    "difficulty": "hard"
  },
  {
    "id": 4,
    "question": "How many times will 'tick' be logged and when?",
    "code": "console.log('start');\nqueueMicrotask(() => console.log('micro'));\nsetTimeout(() => console.log('macrotask'), 0);\nPromise.resolve().then(() => console.log('promise'));\nconsole.log('end');",
    "options": [
      "start, end, micro, promise, macrotask",
      "start, end, promise, micro, macrotask",
      "start, micro, end, promise, macrotask",
      "start, end, micro+promise in unspecified order, macrotask"
    ],
    "answer": 0,
    "explain": "ðŸ§  Detailed Explanation (Three Key Points)\n\n1).  Synchronous Phase\n- Logs `'start'` first.\n- `queueMicrotask` and `Promise.then` both schedule microtasks.\n- `setTimeout` schedules a macrotask.\n- Logs `'end'` at the end of the current call stack.\n\n2).  Microtask Phase\n- All microtasks run after synchronous code.\n- They execute in FIFO order â€” `'micro'` first (queued first), then `'promise'`.\n\n3).  Macrotask Phase\n- Once the microtask queue is empty, the event loop processes macrotasks.\n- `'macrotask'` logs last.\n\nðŸ§¾ Final Order: start â†’ end â†’ micro â†’ promise â†’ macrotask",
    "difficulty": "medium"
  },
  {
    "id": 5,
    "question": "What will this log sequence be?",
    "code": "async function foo() {\n  console.log('inside');\n}\nconsole.log('a');\nfoo().then(() => console.log('after foo'));\nconsole.log('b');",
    "options": [
      "a, inside, b, after foo",
      "a, b, inside, after foo",
      "a, inside, after foo, b",
      "a, b, after foo, inside"
    ],
    "answer": 0,
    "explain": "ðŸ§  Detailed Explanation (Three Key Points)\n\n1).  Synchronous Phase\n- `console.log('a')` runs first.\n- Calling `foo()` executes the function body synchronously up to the first `await` (none here), so `'inside'` is logged immediately.\n- Then `console.log('b')` executes before the promise resolves.\n\n2).  Microtask Phase (Promise Resolution)\n- Since `foo()` returns a resolved Promise, its `.then()` callback (`after foo`) is scheduled as a microtask.\n- After the main script finishes, `'after foo'` logs next.\n\n3).  Macrotask Phase\n- There are no macrotasks scheduled.\n\nðŸ§¾ Final Order: a â†’ inside â†’ b â†’ after foo",
    "difficulty": "medium"
  },
  {
    "id": 6,
    "question": "What prints first: 'promise' or 'raf'?",
    "code": "setTimeout(() => console.log('timeout'), 0);\nrequestAnimationFrame(() => console.log('raf'));\nPromise.resolve().then(() => console.log('promise'));",
    "options": [
      "promise, raf, timeout",
      "raf, promise, timeout",
      "timeout, promise, raf",
      "promise, timeout, raf"
    ],
    "answer": 0,
    "explain": "ðŸ§  Detailed Explanation (Three Key Points)\n\n1).  Microtasks Run First\n- The resolved Promise schedules a microtask.\n- `'promise'` logs before any rendering or macrotasks.\n\n2).  Animation Frame Callbacks Next\n- `requestAnimationFrame()` runs before the next repaint, which happens after microtasks.\n- `'raf'` logs next.\n\n3).  Macrotasks Last\n- `setTimeout()` callback runs after the next event loop tick.\n- `'timeout'` logs last.\n\nðŸ§¾ Final Order: promise â†’ raf â†’ timeout",
    "difficulty": "hard"
  },
  {
    "id": 7,
    "question": "What will be printed and why?",
    "code": "console.log('start');\nsetTimeout(() => console.log('t1'), 0);\nsetTimeout(() => console.log('t2'), 0);\nPromise.resolve().then(() => console.log('p1'));\nPromise.resolve().then(() => console.log('p2'));\nconsole.log('end');",
    "options": [
      "start, end, p1, p2, t1, t2",
      "start, end, p1, p2, t2, t1",
      "start, p1, p2, end, t1, t2",
      "start, end, t1, t2, p1, p2"
    ],
    "answer": 0,
    "explain": "ðŸ§  Detailed Explanation (Three Key Points)\n\n1).  Synchronous Code Runs First\n- `'start'` logs first.\n- Two `setTimeout()` callbacks (`t1` and `t2`) are queued as macrotasks.\n- Two Promises are queued as microtasks.\n- `'end'` logs before leaving the stack.\n\n2).  Microtask Phase\n- Promise callbacks are executed in insertion order.\n- `'p1'` logs first, then `'p2'`.\n\n3).  Macrotask Phase\n- After microtasks finish, macrotasks (`t1`, `t2`) run in the order they were scheduled.\n\nðŸ§¾ Final Order: start â†’ end â†’ p1 â†’ p2 â†’ t1 â†’ t2",
    "difficulty": "medium"
  },
  {
    "id": 8,
    "question": "Which logs first?",
    "code": "Promise.resolve().then(() => console.log('promise1'));\nqueueMicrotask(() => console.log('qmicro'));\nPromise.resolve().then(() => console.log('promise2'));\n",
    "options": [
      "promise1, qmicro, promise2",
      "qmicro, promise1, promise2",
      "promise1, promise2, qmicro",
      "All in unspecified order"
    ],
    "answer": 1,
    "explain": "ðŸ§  Detailed Explanation (Three Key Points)\n\n1).  Synchronous Setup\n- All microtasks are scheduled in order: first `promise1`, then `queueMicrotask`, then `promise2`.\n\n2).  Microtask Execution Order\n- Microtasks execute in FIFO order.\n- So `'promise1'` runs first (added first), then `'qmicro'`, then `'promise2'`.\n\n3).  No Macrotasks Here\n- Only the microtask queue runs, as no timers or async tasks exist.\n\nðŸ§¾ Final Order: promise1 â†’ qmicro â†’ promise2",
    "difficulty": "hard"
  },
  {
    "id": 9,
    "question": "What is logged and why?",
    "code": "console.log('S');\nsetTimeout(() => console.log('T'), 0);\n(async () => { await null; console.log('A'); })();\nconsole.log('E');",
    "options": [
      "S, E, A, T",
      "S, A, E, T",
      "S, E, T, A",
      "S, E, A, T or S, E, T, A depending on engine"
    ],
    "answer": 0,
    "explain": "ðŸ§  Detailed Explanation (Three Key Points)\n\n1).  Synchronous Phase\n- `'S'` logs immediately.\n- `setTimeout` schedules `'T'` as a macrotask.\n- The async function begins execution and hits `await null`, yielding control.\n- `'E'` logs before the async continuation resumes.\n\n2).  Microtask Phase\n- The `await` resumes the async function as a microtask.\n- `'A'` logs next.\n\n3).  Macrotask Phase\n- The `'T'` from `setTimeout` executes last.\n\nðŸ§¾ Final Order: S â†’ E â†’ A â†’ T",
    "difficulty": "medium"
  },
  {
    "id": 10,
    "question": "What happens first: MutationObserver callback or Promise.then microtask?",
    "code": "const div = document.createElement('div');\nconst mo = new MutationObserver(() => console.log('mo'));\nmo.observe(div, { attributes: true });\nPromise.resolve().then(() => console.log('promise'));\ndiv.setAttribute('id', 'x');",
    "options": [
      "promise, mo",
      "mo, promise",
      "Both called together (same timing)",
      "Order unspecified and engine-dependent"
    ],
    "answer": 0,
    "explain": "ðŸ§  Detailed Explanation (Three Key Points)\n\n1).  Synchronous Setup\n- A MutationObserver is created and observes changes on `div`.\n- The attribute mutation queues a MutationRecord for later processing.\n- The Promise schedules its `.then()` callback as a microtask.\n\n2).  Microtask Phase\n- Regular microtasks like `Promise.then()` run before MutationObserver callbacks.\n- `'promise'` logs first.\n\n3).  End of Microtask Checkpoint\n- After all microtasks, the browser delivers MutationObserver callbacks.\n- `'mo'` logs next.\n\nðŸ§¾ Final Order: promise â†’ mo",
    "difficulty": "hard"
  },
  {
    "id": 11,
    "question": "What will this print and why?",
    "code": "console.log('1');\nPromise.resolve().then(() => { console.log('2'); queueMicrotask(() => console.log('3')); }).then(() => console.log('4'));\nconsole.log('5');",
    "options": [
      "1,5,2,3,4",
      "1,5,2,4,3",
      "1,2,3,4,5",
      "1,5,2,4,3 or engine dependent"
    ],
    "answer": 1,
    "explain": "ðŸ§  Detailed Explanation (Three Key Points)\n\n1).  Synchronous Phase\n- `'1'` logs first.\n- The chained Promises and microtasks are registered.\n- `'5'` logs before any async tasks.\n\n2).  Microtask Queue Execution\n- The first `.then()` logs `'2'` and queues another microtask `'3'`.\n- The chained `.then()` (`'4'`) is queued before `'3'`, as itâ€™s created immediately after the first `.then()` resolves.\n- Hence, `'4'` runs before `'3'`.\n\n3).  Macrotasks\n- None here.\n\nðŸ§¾ Final Order: 1 â†’ 5 â†’ 2 â†’ 4 â†’ 3",
    "difficulty": "hard"
  },
  {
    "id": 12,
    "question": "Which happens first in Node.js: process.nextTick or Promise microtasks?",
    "code": "process.nextTick(() => console.log('nextTick'));\nPromise.resolve().then(() => console.log('promise'));\n",
    "options": [
      "nextTick, promise",
      "promise, nextTick",
      "Both run in unspecified order",
      "Neither runs in this phase"
    ],
    "answer": 0,
    "explain": "ðŸ§  Detailed Explanation (Three Key Points)\n\n1).  Scheduling\n- `process.nextTick` callbacks go into a special queue that runs before any other microtasks in Node.js.\n- The Promise `.then()` callback is queued as a regular microtask.\n\n2).  Execution Order\n- Node.js always clears the nextTick queue before handling the microtask queue.\n- Hence `'nextTick'` logs before `'promise'`.\n\n3).  Macrotask Phase\n- None involved.\n\nðŸ§¾ Final Order: nextTick â†’ promise",
    "difficulty": "hard"
  },
  {
    "id": 13,
    "question": "What is the printed order?",
    "code": "setTimeout(() => console.log('t1'), 0);\nPromise.resolve().then(() => console.log('p1'));\nsetTimeout(() => Promise.resolve().then(() => console.log('p2-from-timeout')) , 0);\n",
    "options": [
      "p1, t1, p2-from-timeout",
      "t1, p1, p2-from-timeout",
      "p1, p2-from-timeout, t1",
      "t1, p2-from-timeout, p1"
    ],
    "answer": 0,
    "explain": "ðŸ§  Detailed Explanation (Three Key Points)\n\n1).  Microtasks First\n- The first `Promise.resolve().then()` logs `'p1'` as a microtask.\n\n2).  Macrotasks\n- `t1` executes first (earliest setTimeout).\n- Inside `t1`, a new microtask (`p2-from-timeout`) is queued.\n\n3).  Microtask Inside Macrotask\n- After `t1` finishes, the microtask `'p2-from-timeout'` runs before the next macrotask.\n\nðŸ§¾ Final Order: p1 â†’ t1 â†’ p2-from-timeout",
    "difficulty": "medium"
  },
  {
    "id": 14,
    "question": "Which logs first: console.log('A') from a resolved async function or a then callback queued by Promise.resolve().then?",
    "code": "async function f(){ return 'x'; }\nf().then(() => console.log('async then'));\nPromise.resolve().then(() => console.log('promise then'));\n",
    "options": [
      "async then, promise then",
      "promise then, async then",
      "They are the same microtask and order is insertion order",
      "Order is engine-dependent"
    ],
    "answer": 2,
    "explain": "ðŸ§  Detailed Explanation (Three Key Points)\n\n1).  Microtask Scheduling\n- Both `f().then(...)` and `Promise.resolve().then(...)` schedule microtasks.\n- They enter the microtask queue in insertion order.\n\n2).  Execution\n- The async functionâ€™s promise resolves first, queuing `'async then'` before `'promise then'`.\n\n3).  Result\n- Both are microtasks and execute sequentially, following FIFO order.\n\nðŸ§¾ Final Order: async then â†’ promise then",
    "difficulty": "hard"
  },
  {
    "id": 15,
    "question": "What prints first: a microtask queued inside a macrotask or a microtask queued before that macrotask?",
    "code": "Promise.resolve().then(() => console.log('m1'));\nsetTimeout(() => { Promise.resolve().then(() => console.log('m2')); console.log('t'); }, 0);",
    "options": [
      "m1, t, m2",
      "m1, m2, t",
      "t, m2, m1",
      "order unspecified"
    ],
    "answer": 0,
    "explain": "ðŸ§  Detailed Explanation (Three Key Points)\n\n1).  Initial Microtasks\n- `'m1'` is queued as a microtask and executes before any macrotasks.\n\n2).  Macrotask Execution\n- The `setTimeout` callback runs next and logs `'t'`.\n- Inside it, `'m2'` is scheduled as a new microtask.\n\n3).  Microtasks After Macrotask\n- `'m2'` runs after `'t'`, before moving to the next macrotask cycle.\n\nðŸ§¾ Final Order: m1 â†’ t â†’ m2",
    "difficulty": "medium"
  },
  {
    "id": 16,
    "question": "What is the output order and why?",
    "code": "console.log('script start');\nasync function async1(){\n  console.log('async1 start');\n  await async2();\n  console.log('async1 end');\n}\nasync function async2(){\n  console.log('async2');\n}\nasync1();\nconsole.log('script end');",
    "options": [
      "script start, async1 start, async2, script end, async1 end",
      "script start, async1 start, async2, async1 end, script end",
      "script start, async2, async1 start, script end, async1 end",
      "script start, script end, async1 start, async2, async1 end"
    ],
    "answer": 0,
    "explain": "ðŸ§  Detailed Explanation (Three Key Points)\n\n1).  Synchronous Phase\n- `'script start'` logs first.\n- Calling `async1()` logs `'async1 start'`.\n- `async2()` logs `'async2'` synchronously.\n- The `await` yields control, pausing `async1()`.\n- `'script end'` logs next.\n\n2).  Microtask Phase\n- The continuation of `async1()` resumes after the current stack.\n- `'async1 end'` logs as a microtask.\n\n3).  Macrotask Phase\n- None here.\n\nðŸ§¾ Final Order: script start â†’ async1 start â†’ async2 â†’ script end â†’ async1 end",
    "difficulty": "medium"
  },
  {
    "id": 17,
    "question": "Which of these statements about Event Loop are true?",
    "code": "",
    "options": [
      "Microtasks always run to completion before next macrotask",
      "Macrotasks can interrupt microtask execution",
      "Microtasks scheduled by a microtask execute in the same microtask checkpoint",
      "MutationObserver callbacks are part of macrotask queue"
    ],
    "answer": [0,2],
    "explain": "ðŸ§  Detailed Explanation (Three Key Points)\n\n1).  Microtasks before Macrotasks\n- The event loop always clears the microtask queue completely before executing the next macrotask.\n\n2).  Chained Microtasks\n- A microtask can schedule another microtask, and it will still run in the same checkpoint before any macrotask.\n\n3).  MutationObservers\n- Their callbacks are part of the microtask phase, not macrotasks.\n\nðŸ§¾ Correct Statements: 1 & 3",
    "difficulty": "hard"
  },
  {
    "id": 18,
    "question": "What is printed and why? (Edge case with long-running microtasks)",
    "code": "console.log('start');\nPromise.resolve().then(() => { for(let i=0;i<1e9;i++){}; console.log('long'); });\nsetTimeout(() => console.log('timeout'), 0);\nconsole.log('end');",
    "options": [
      "start, end, long, timeout â€” long delays UI",
      "start, long, end, timeout",
      "start, end, timeout, long",
      "start, end, timeout and long may never run"
    ],
    "answer": 0,
    "explain": "ðŸ§  Detailed Explanation (Three Key Points)\n\n1).  Synchronous Phase (Call Stack)\n- `console.log('start')` runs first.\n- The Promise `.then(...)` callback is scheduled as a microtask.\n- `setTimeout(..., 0)` schedules a macrotask (timer).\n- `console.log('end')` runs before the microtask executes.\n\n2).  Microtask Phase (Blocking Work Happens Here)\n- The microtask runs immediately after the current stack completes.\n- The microtask contains a very long synchronous loop (`for (let i=0;i<1e9;i++) {}`) â€” this blocks the main thread while it runs.\n- Only after that loop finishes does the microtask execute its `console.log('long')`.\n\n3).  Macrotask Phase (Timers Run After Microtasks)\n- After the microtask queue is emptied, the event loop picks the next macrotask â€” the `setTimeout` callback â€” which logs `'timeout'`.\n- Because the microtask contains long, CPU-bound work, it will delay the macrotask and any UI updates (this is why long-running microtasks are harmful).\n\nðŸ§¾ Final Order: start â†’ end â†’ long â†’ timeout\n\n(Notes: The long loop blocks the thread during the microtask; this is why UI and timers are delayed until the microtask finishes.)",
    "difficulty": "medium"
  },
  {
    "id": 19,
    "question": "What will be the logged order in a Promise chain that schedules another microtask inside a then?",
    "code": "Promise.resolve()\n  .then(() => { console.log('a'); Promise.resolve().then(() => console.log('c')); })\n  .then(() => console.log('b'));\n",
    "options": [
      "a, b, c",
      "a, c, b",
      "c, a, b",
      "b, a, c"
    ],
    "answer": 1,
    "explain": "ðŸ§  Detailed Explanation (Three Key Points)\n\n1).  Synchronous Phase\n- The script schedules microtasks via `.then()` calls. Nothing logs synchronously here because the `.then()` callbacks run as microtasks.\n\n2).  First Microtask Executes (logs 'a')\n- The first `.then()` callback runs and logs `'a'`.\n- Inside that callback, you create another microtask (`Promise.resolve().then(() => console.log('c'))`), which is appended to the end of the microtask queue.\n- Also, the outer `.then(...).then(() => console.log('b'))` chain schedules the `'b'` callback as the next microtask that represents the resolution of the first `.then()` chain.\n\n3).  Microtask Queue Ordering & Outcome (subtle / engine nuance)\n- The microtask queue is FIFO. The relative order of the chained `.then(() => console.log('b'))` vs the inner microtask (`'c'`) depends on precisely when the promise resolution and inner microtask were enqueued.\n- In many mainstream engines the chained `.then('b')` is queued before the inner microtask `'c'`, producing: `a â†’ b â†’ c`.\n- However, some explanations and engine behaviors treat the newly queued inner microtask as coming earlier, which would give `a â†’ c â†’ b`.\n\nðŸ§¾ Common (and safe) statement: `a` runs first; then `b` and `c` follow, but the exact order of `b` vs `c` can be subtle and is an implementation detail. Many engines yield `a â†’ b â†’ c`. If your dataset expects `a â†’ c â†’ b`, note that this is an engine-dependent edge-case; test in the target runtime for a definitive ordering.",
    "difficulty": "hard"
  },
  {
    "id": 20,
    "question": "Which is true about web worker / worker threads and event loop?",
    "code": "",
    "options": [
      "Each worker has its own event loop and call stack",
      "Workers share the main thread's event loop",
      "Workers have no microtask queue",
      "Workers execute microtasks as macrotasks"
    ],
    "answer": 0,
    "explain": "ðŸ§  Detailed Explanation (Three Key Points)\n\n1).  Isolation & Threading\n- Web Workers / Worker Threads run in separate threads from the main thread.\n- Each worker has its own call stack, so JavaScript running in a worker does not block the main thread (and vice versa).\n\n2).  Event Loop Per Worker\n- Each worker also has its own event loop and task queues (macrotasks and microtasks).\n- This means timers, message events, and Promise microtasks are all processed within that workerâ€™s event loop.\n\n3).  Microtask Support\n- Workers support microtasks (Promise callbacks, `queueMicrotask`, etc.) and process them in the same microtask checkpoint semantics as the main thread â€” they are not treated as macrotasks.\n\nðŸ§¾ Final: Each worker has its own event loop and call stack (Option 1).",
    "difficulty": "medium"
  }
  
  ,{
    "id": 21,
    "question": "What is the output of this code?",
    "code": "function makeAdder(x) {\n  return function(y) {\n    return x + y;\n  };\n}\nconst add5 = makeAdder(5);\nconsole.log(add5(2));",
    "options": [
      "7",
      "5",
      "2",
      "Error"
    ],
    "answer": 0,
    "explain": "The inner function forms a closure over 'x'. When called later with y=2, x remains 5 â†’ 5 + 2 = 7.",
    "difficulty": "easy"
  },
  {
    "id": 22,
    "question": "What gets logged here?",
    "code": "let count = 0;\nfunction counter() {\n  count++;\n  return function() {\n    console.log(count);\n  };\n}\nconst c1 = counter();\nconst c2 = counter();\nc1();\nc2();",
    "options": [
      "1, 2",
      "2, 2",
      "1, 1",
      "Error"
    ],
    "answer": 0,
    "explain": "Each call to counter increments the shared variable `count`. Both closures refer to the same outer `count`, so it logs 1 and then 2.",
    "difficulty": "medium"
  },
  {
    "id": 23,
    "question": "What will be printed?",
    "code": "function outer() {\n  let x = 10;\n  function inner() {\n    console.log(x);\n  }\n  x = 20;\n  return inner;\n}\nconst fn = outer();\nfn();",
    "options": [
      "10",
      "20",
      "undefined",
      "Error"
    ],
    "answer": 1,
    "explain": "Closures capture variables by reference, not by value. When inner is executed, x has been updated to 20.",
    "difficulty": "medium"
  },
  {
    "id": 24,
    "question": "What is the result of this IIFE?",
    "code": "(function() {\n  let secret = 'hidden';\n  console.log(secret);\n})();\nconsole.log(typeof secret);",
    "options": [
      "hidden, string",
      "hidden, undefined",
      "undefined, string",
      "Error"
    ],
    "answer": 1,
    "explain": "`secret` is scoped inside the IIFE (private). Outside itâ€™s undefined, so typeof secret === 'undefined'.",
    "difficulty": "easy"
  },
  {
    "id": 25,
    "question": "What is logged?",
    "code": "function makeCounter() {\n  let value = 0;\n  return {\n    increment: function() { value++; },\n    get: function() { console.log(value); }\n  };\n}\nconst counter = makeCounter();\ncounter.increment();\ncounter.increment();\ncounter.get();",
    "options": [
      "0",
      "1",
      "2",
      "undefined"
    ],
    "answer": 2,
    "explain": "`value` is private to `makeCounter`. Two increments make it 2. The closure remembers its own variable even after makeCounter() ends.",
    "difficulty": "medium"
  },
  {
    "id": 26,
    "question": "What happens here?",
    "code": "function secretHolder() {\n  let secret = 42;\n  return () => secret;\n}\nconst getSecret = secretHolder();\nconsole.log(getSecret());\nconsole.log(secret);",
    "options": [
      "42, 42",
      "42, undefined",
      "Error, secret not defined",
      "undefined, 42"
    ],
    "answer": 2,
    "explain": "`secret` is block-scoped inside secretHolder(). The returned closure can access it, but the outer scope cannot.",
    "difficulty": "easy"
  },
  {
    "id": 27,
    "question": "What will the following code log?",
    "code": "function outer() {\n  let x = 0;\n  return function inner() {\n    x++;\n    console.log(x);\n  };\n}\nconst fn1 = outer();\nfn1();\nfn1();\nconst fn2 = outer();\nfn2();",
    "options": [
      "1, 2, 3",
      "1, 2, 1",
      "0, 1, 2",
      "2, 3, 1"
    ],
    "answer": 1,
    "explain": "Each call to outer creates a new closure with its own `x`. fn1 increments its `x` twice (1,2). fn2 starts fresh (1).",
    "difficulty": "medium"
  },
  {
    "id": 28,
    "question": "What is logged and why?",
    "code": "function outer() {\n  let a = 1;\n  return function inner() {\n    console.log(++a);\n  };\n}\nconst x = outer();\nconst y = outer();\nx();\nx();\ny();",
    "options": [
      "2, 3, 4",
      "2, 3, 2",
      "1, 2, 1",
      "undefined"
    ],
    "answer": 1,
    "explain": "Each call to outer creates a separate closure. x() increments its own a (1â†’2â†’3), y() has its own (1â†’2).",
    "difficulty": "medium"
  },
  {
    "id": 29,
    "question": "What gets printed?",
    "code": "for (var i = 0; i < 3; i++) {\n  setTimeout(function() {\n    console.log(i);\n  }, 100);\n}",
    "options": [
      "0 1 2",
      "3 3 3",
      "0 0 0",
      "Error"
    ],
    "answer": 1,
    "explain": "`var` is function-scoped, so all callbacks share the same i, which is 3 after the loop finishes. Use `let` to fix it.",
    "difficulty": "medium"
  },
  {
    "id": 30,
    "question": "What will be logged with `let` instead of `var`?",
    "code": "for (let i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 100);\n}",
    "options": [
      "3 3 3",
      "0 1 2",
      "undefined undefined undefined",
      "Error"
    ],
    "answer": 1,
    "explain": "`let` creates a new lexical binding of `i` for each loop iteration. Each closure captures its own `i` value.",
    "difficulty": "easy"
  },
  {
    "id": 31,
    "question": "What is the output?",
    "code": "function create() {\n  let value = 0;\n  return {\n    inc: () => ++value,\n    dec: () => --value\n  };\n}\nconst counter = create();\ncounter.inc();\ncounter.inc();\nconsole.log(counter.dec());",
    "options": [
      "1",
      "2",
      "0",
      "undefined"
    ],
    "answer": 0,
    "explain": "After two increments value=2, then decrement â†’ 1. Closure keeps value private and persistent.",
    "difficulty": "medium"
  },
  {
    "id": 32,
    "question": "What is printed and why?",
    "code": "function outer(a) {\n  return function(b) {\n    return function(c) {\n      console.log(a + b + c);\n    };\n  };\n}\nouter(1)(2)(3);",
    "options": [
      "6",
      "123",
      "Error",
      "undefined"
    ],
    "answer": 0,
    "explain": "Each returned function forms a closure over previous arguments (a, b). When final function executes, all variables are in scope â†’ 1+2+3=6.",
    "difficulty": "easy"
  },
  {
    "id": 33,
    "question": "What gets logged here?",
    "code": "function counter() {\n  let count = 0;\n  return function() {\n    return count++;\n  };\n}\nconst c = counter();\nconsole.log(c());\nconsole.log(c());\nconsole.log(c());",
    "options": [
      "0 1 2",
      "1 2 3",
      "undefined undefined undefined",
      "Error"
    ],
    "answer": 0,
    "explain": "Post-increment returns old value first, then increments. Each call uses same closure variable.",
    "difficulty": "medium"
  },
  {
    "id": 34,
    "question": "What is logged?",
    "code": "function makeObject() {\n  let hidden = 10;\n  return {\n    show: () => hidden,\n    increase: () => hidden++\n  };\n}\nconst obj1 = makeObject();\nconst obj2 = makeObject();\nobj1.increase();\nconsole.log(obj1.show(), obj2.show());",
    "options": [
      "11 10",
      "10 10",
      "11 11",
      "Error"
    ],
    "answer": 0,
    "explain": "Each object from makeObject() gets its own closure. obj1 and obj2 do not share hidden.",
    "difficulty": "medium"
  },
  {
    "id": 35,
    "question": "What happens when running this code?",
    "code": "function createCounter() {\n  let count = 0;\n  return {\n    increment: () => ++count\n  };\n}\nconst c1 = createCounter();\nconst c2 = c1;\nc1.increment();\nc2.increment();\nconsole.log(c1.increment());",
    "options": [
      "1",
      "2",
      "3",
      "Error"
    ],
    "answer": 2,
    "explain": "Both c1 and c2 reference the same closure object. Shared state count goes 0â†’1â†’2â†’3.",
    "difficulty": "medium"
  },
  {
    "id": 36,
    "question": "What will this log?",
    "code": "function foo() {\n  var bar = 'secret';\n  setTimeout(function() {\n    console.log(bar);\n  }, 1000);\n  bar = 'revealed';\n}\nfoo();",
    "options": [
      "secret",
      "revealed",
      "undefined",
      "Error"
    ],
    "answer": 1,
    "explain": "Closures capture variable references, not values. When setTimeout runs, bar has been updated to 'revealed'.",
    "difficulty": "medium"
  },
  {
    "id": 37,
    "question": "What is the output?",
    "code": "function wrapper() {\n  const privateVal = 100;\n  return function() {\n    return privateVal;\n  };\n}\nconst access = wrapper();\nconsole.log(access());\nconsole.log(privateVal);",
    "options": [
      "100, undefined",
      "undefined, 100",
      "Error",
      "100, Error"
    ],
    "answer": 3,
    "explain": "privateVal is not accessible outside wrapper scope, so direct access throws ReferenceError.",
    "difficulty": "medium"
  },
  {
    "id": 38,
    "question": "What does this code demonstrate?",
    "code": "const bankAccount = (function() {\n  let balance = 1000;\n  return {\n    deposit(amount) { balance += amount; },\n    withdraw(amount) { balance -= amount; },\n    getBalance() { return balance; }\n  };\n})();",
    "options": [
      "Encapsulation using closures",
      "Prototype inheritance",
      "Async event handling",
      "Lexical hoisting"
    ],
    "answer": 0,
    "explain": "An IIFE creates private state (balance) with controlled access via closure functions â€” a pattern for encapsulation.",
    "difficulty": "easy"
  },
  {
    "id": 39,
    "question": "What is logged?",
    "code": "function tricky() {\n  let arr = [];\n  for (var i = 0; i < 3; i++) {\n    arr.push(() => i);\n  }\n  return arr;\n}\nconst result = tricky();\nconsole.log(result[0](), result[1](), result[2]());",
    "options": [
      "0 1 2",
      "3 3 3",
      "undefined undefined undefined",
      "Error"
    ],
    "answer": 1,
    "explain": "Because var is function-scoped, all closures share same `i` which is 3 after the loop. Using `let` fixes it.",
    "difficulty": "medium"
  },
  {
    "id": 40,
    "question": "What will be the output here?",
    "code": "function createFunctions() {\n  let arr = [];\n  for (let i = 0; i < 3; i++) {\n    arr.push(() => i);\n  }\n  return arr;\n}\nconst funcs = createFunctions();\nconsole.log(funcs[0](), funcs[1](), funcs[2]());",
    "options": [
      "0 1 2",
      "3 3 3",
      "undefined undefined undefined",
      "Error"
    ],
    "answer": 0,
    "explain": "Using `let` creates a new lexical environment for each iteration. Each closure captures its own value of i.",
    "difficulty": "easy"
  },{
    "id": 41,
    "question": "What is the output of this code?",
    "code": "function Person(name) {\n  this.name = name;\n}\nPerson.prototype.greet = function() {\n  return 'Hello ' + this.name;\n};\nconst p = new Person('Sunil');\nconsole.log(p.greet());",
    "options": [
      "'Hello Sunil'",
      "'undefined'",
      "Error",
      "'Hello [object Object]'"
    ],
    "answer": 0,
    "explain": "Instances created with `new` link their internal `[[Prototype]]` to `Person.prototype`, so `p.greet()` works via the prototype chain.",
    "difficulty": "easy"
  },
  {
    "id": 42,
    "question": "What is true about `__proto__` and `prototype`?",
    "code": "",
    "options": [
      "`__proto__` is an internal link of objects; `prototype` exists only on functions.",
      "`prototype` is the parent of all objects.",
      "They are the same.",
      "Neither are accessible in JavaScript."
    ],
    "answer": 0,
    "explain": "`__proto__` (or `[[Prototype]]`) points to the object's prototype. `prototype` is a property only of constructor functions.",
    "difficulty": "medium"
  },
  {
    "id": 43,
    "question": "What gets logged?",
    "code": "function A() {}\nA.prototype.x = 10;\nconst obj = new A();\nconsole.log(obj.x);\nconsole.log(obj.hasOwnProperty('x'));",
    "options": [
      "10, true",
      "undefined, false",
      "10, false",
      "Error"
    ],
    "answer": 2,
    "explain": "x is found via the prototype chain, not as an own property, so `obj.hasOwnProperty('x')` is false.",
    "difficulty": "medium"
  },
  {
    "id": 44,
    "question": "What is the prototype of `Object.prototype`?",
    "options": [
      "null",
      "undefined",
      "Function.prototype",
      "Object"
    ],
    "answer": 0,
    "explain": "The prototype chain ends at `Object.prototype.__proto__ === null`.",
    "difficulty": "easy"
  },
  {
    "id": 45,
    "question": "What is the output?",
    "code": "function Animal() {}\nAnimal.prototype.sound = 'growl';\nconst cat = new Animal();\ncat.sound = 'meow';\nconsole.log(cat.sound);\ndelete cat.sound;\nconsole.log(cat.sound);",
    "options": [
      "'growl', 'growl'",
      "'meow', 'growl'",
      "'meow', 'undefined'",
      "'growl', 'undefined'"
    ],
    "answer": 1,
    "explain": "After deletion, the property lookup falls back to `Animal.prototype.sound` via prototype chain.",
    "difficulty": "medium"
  },
  {
    "id": 46,
    "question": "What is true about the `prototype` property?",
    "options": [
      "All objects have it.",
      "Only functions have it.",
      "Only arrays have it.",
      "It is the same as `__proto__`."
    ],
    "answer": 1,
    "explain": "Only constructor functions and classes have the `prototype` property used when creating new instances with `new`.",
    "difficulty": "medium"
  },
  {
    "id": 47,
    "question": "What is logged here?",
    "code": "function Car() {}\nCar.prototype.wheels = 4;\nconst tesla = new Car();\nCar.prototype.wheels = 6;\nconsole.log(tesla.wheels);",
    "options": [
      "4",
      "6",
      "undefined",
      "Error"
    ],
    "answer": 1,
    "explain": "All instances share the prototype object. When its property changes, all instances reflect the new value unless overridden.",
    "difficulty": "medium"
  },
  {
    "id": 48,
    "question": "What is the result of the following code?",
    "code": "const parent = { a: 1 };\nconst child = Object.create(parent);\nchild.b = 2;\nconsole.log(child.a + child.b);",
    "options": [
      "3",
      "undefined",
      "1",
      "2"
    ],
    "answer": 0,
    "explain": "child inherits from parent. Accessing child.a looks up the prototype chain â†’ parent.a = 1.",
    "difficulty": "easy"
  },
  {
    "id": 49,
    "question": "What is `child.__proto__ === parent` after this code?",
    "code": "const parent = { kind: 'human' };\nconst child = Object.create(parent);",
    "options": [
      "true",
      "false",
      "undefined",
      "Error"
    ],
    "answer": 0,
    "explain": "`Object.create(parent)` sets child's internal `[[Prototype]]` (i.e. `__proto__`) to parent.",
    "difficulty": "easy"
  },
  {
    "id": 50,
    "question": "What will the output be?",
    "code": "function Foo() {}\nFoo.prototype.bar = 42;\nconst f = new Foo();\nconsole.log(Object.getPrototypeOf(f) === Foo.prototype);",
    "options": [
      "true",
      "false",
      "undefined",
      "Error"
    ],
    "answer": 0,
    "explain": "`Object.getPrototypeOf(f)` returns the same object as `Foo.prototype` for instances created with `new Foo()`.",
    "difficulty": "medium"
  },
  {
    "id": 51,
    "question": "What gets logged?",
    "code": "const animal = { eats: true };\nconst rabbit = Object.create(animal);\nrabbit.eats = false;\nconsole.log(rabbit.eats);\ndelete rabbit.eats;\nconsole.log(rabbit.eats);",
    "options": [
      "false, undefined",
      "false, true",
      "true, false",
      "undefined, true"
    ],
    "answer": 1,
    "explain": "After deletion, lookup falls back to prototype `animal.eats`, so logs true.",
    "difficulty": "medium"
  },
  {
    "id": 52,
    "question": "Which statement is correct about function constructors?",
    "options": [
      "They must return an object.",
      "They automatically return the instance when called with `new`.",
      "They are just class aliases.",
      "They have no prototype by default."
    ],
    "answer": 1,
    "explain": "Constructors return `this` (the new instance) automatically unless another object is explicitly returned.",
    "difficulty": "easy"
  },
  {
    "id": 53,
    "question": "What is logged?",
    "code": "function Person() {}\nPerson.prototype.sayHi = function() { console.log('Hi'); };\nconst p = new Person();\np.__proto__.sayHi();",
    "options": [
      "Hi",
      "undefined",
      "Error",
      "Nothing"
    ],
    "answer": 0,
    "explain": "p.__proto__ points to Person.prototype, which contains sayHi.",
    "difficulty": "easy"
  },
  {
    "id": 54,
    "question": "What happens when using `class` syntax?",
    "code": "class Animal {\n  speak() { return 'sound'; }\n}\nconst a = new Animal();\nconsole.log(a.__proto__ === Animal.prototype);",
    "options": [
      "true",
      "false",
      "undefined",
      "Error"
    ],
    "answer": 0,
    "explain": "Class syntax is syntactic sugar over prototypes. Instances link to Class.prototype.",
    "difficulty": "medium"
  },
  {
    "id": 55,
    "question": "What is the output?",
    "code": "function A() {}\nfunction B() {}\nB.prototype = new A();\nconst b = new B();\nconsole.log(b instanceof A);",
    "options": [
      "true",
      "false",
      "undefined",
      "Error"
    ],
    "answer": 0,
    "explain": "b.__proto__ â†’ B.prototype â†’ (instance of A). The chain includes A.prototype, so instanceof A is true.",
    "difficulty": "medium"
  },
  {
    "id": 56,
    "question": "What happens when overwriting prototype?",
    "code": "function Car() {}\nCar.prototype = { wheels: 4 };\nconst c = new Car();\nconsole.log(c.constructor === Car);",
    "options": [
      "true",
      "false",
      "undefined",
      "Error"
    ],
    "answer": 1,
    "explain": "Replacing the entire prototype removes the default `constructor` link. c.constructor now points to Object by default.",
    "difficulty": "hard"
  },
  {
    "id": 57,
    "question": "What is printed?",
    "code": "const grandparent = { level: 'grand' };\nconst parent = Object.create(grandparent);\nconst child = Object.create(parent);\nconsole.log(child.level);",
    "options": [
      "'grand'",
      "'parent'",
      "undefined",
      "Error"
    ],
    "answer": 0,
    "explain": "The lookup follows the prototype chain: child â†’ parent â†’ grandparent.",
    "difficulty": "easy"
  },
  {
    "id": 58,
    "question": "What does this return?",
    "code": "function X() {}\nX.prototype = { foo: 1 };\nconst x1 = new X();\nconst x2 = new X();\nconsole.log(x1.foo === x2.foo);",
    "options": [
      "true",
      "false",
      "undefined",
      "Error"
    ],
    "answer": 0,
    "explain": "Both instances share the same prototype object, so they access the same `foo` property value.",
    "difficulty": "easy"
  },
  {
    "id": 59,
    "question": "What is logged?",
    "code": "function Shape() {}\nShape.prototype.name = 'shape';\nconst s = new Shape();\nconsole.log('name' in s);\nconsole.log(s.hasOwnProperty('name'));",
    "options": [
      "true, true",
      "true, false",
      "false, true",
      "false, false"
    ],
    "answer": 1,
    "explain": "The `in` operator checks the prototype chain; hasOwnProperty checks only direct properties.",
    "difficulty": "medium"
  },
  {
    "id": 60,
    "question": "What will be output?",
    "code": "const obj = {};\nconsole.log(Object.getPrototypeOf(obj) === Object.prototype);\nconsole.log(obj.__proto__ === Object.prototype);",
    "options": [
      "true, true",
      "false, false",
      "true, false",
      "false, true"
    ],
    "answer": 0,
    "explain": "Both access the internal `[[Prototype]]` of `obj`. They point to Object.prototype by default.",
    "difficulty": "easy"
  }, {
    "id": 61,
    "question": "What will this code log?",
    "code": "console.log(a);\nvar a = 10;",
    "options": [
      "undefined",
      "10",
      "ReferenceError",
      "TypeError"
    ],
    "answer": 0,
    "explain": "`var` declarations are hoisted but not initialized. The variable exists with value `undefined` until assignment.",
    "difficulty": "easy"
  },
  {
    "id": 62,
    "question": "What is logged?",
    "code": "console.log(a);\nlet a = 10;",
    "options": [
      "undefined",
      "10",
      "ReferenceError",
      "TypeError"
    ],
    "answer": 2,
    "explain": "`let` declarations are hoisted but remain uninitialized in the Temporal Dead Zone (TDZ) until the line of declaration.",
    "difficulty": "medium"
  },
  {
    "id": 63,
    "question": "What is the result?",
    "code": "console.log(foo());\nfunction foo() { return 42; }",
    "options": [
      "42",
      "undefined",
      "ReferenceError",
      "TypeError"
    ],
    "answer": 0,
    "explain": "Function declarations are hoisted fully â€” both their name and body â€” so `foo()` is callable before declaration.",
    "difficulty": "easy"
  },
  {
    "id": 64,
    "question": "What happens here?",
    "code": "foo();\nvar foo = function() { console.log('Hello'); };",
    "options": [
      "Hello",
      "undefined",
      "TypeError",
      "ReferenceError"
    ],
    "answer": 2,
    "explain": "The variable `foo` is hoisted but initialized as `undefined`. Attempting to call it before assignment causes TypeError: foo is not a function.",
    "difficulty": "medium"
  },
  {
    "id": 65,
    "question": "What is printed?",
    "code": "console.log(x);\nvar x;\nx = 5;\nconsole.log(x);",
    "options": [
      "undefined, 5",
      "5, 5",
      "undefined, undefined",
      "Error"
    ],
    "answer": 0,
    "explain": "`x` is hoisted as undefined, then assigned later. The first log is undefined, then 5.",
    "difficulty": "easy"
  },
  {
    "id": 66,
    "question": "What gets logged?",
    "code": "var a = 1;\nfunction test() {\n  console.log(a);\n  var a = 2;\n}\ntest();",
    "options": [
      "1",
      "2",
      "undefined",
      "ReferenceError"
    ],
    "answer": 2,
    "explain": "Inside `test`, `var a` is hoisted and shadows the global `a`. It is undefined until assigned (local hoisting).",
    "difficulty": "medium"
  },
  {
    "id": 67,
    "question": "What will the following code output?",
    "code": "function foo() {\n  console.log(a);\n  var a = 2;\n  function a() {}\n}\nfoo();",
    "options": [
      "2",
      "undefined",
      "function a() {}",
      "Error"
    ],
    "answer": 2,
    "explain": "Function declarations are hoisted before vars. So `a` is initially the function. The log prints the function definition.",
    "difficulty": "hard"
  },
  {
    "id": 68,
    "question": "What is the result?",
    "code": "console.log(a);\nconst a = 3;",
    "options": [
      "undefined",
      "3",
      "ReferenceError",
      "TypeError"
    ],
    "answer": 2,
    "explain": "`const` has a Temporal Dead Zone. Access before declaration throws ReferenceError.",
    "difficulty": "medium"
  },
  {
    "id": 69,
    "question": "What happens here?",
    "code": "foo();\nfunction foo() { console.log('A'); }\nvar foo = function() { console.log('B'); };",
    "options": [
      "A",
      "B",
      "Error",
      "undefined"
    ],
    "answer": 0,
    "explain": "Function declarations are hoisted before variable assignments. The call executes the first definition before reassignment.",
    "difficulty": "hard"
  },
  {
    "id": 70,
    "question": "What gets logged?",
    "code": "console.log(a);\nvar a = 5;\nfunction a() {}\nconsole.log(a);",
    "options": [
      "function a() {}, 5",
      "undefined, 5",
      "function a() {}, function a() {}",
      "undefined, undefined"
    ],
    "answer": 0,
    "explain": "Function declaration is hoisted above var. First log shows the function. After assignment, a becomes 5.",
    "difficulty": "hard"
  },
  {
    "id": 71,
    "question": "What is printed?",
    "code": "let a = 10;\n(function() {\n  console.log(a);\n  let a = 20;\n})();",
    "options": [
      "10",
      "20",
      "undefined",
      "ReferenceError"
    ],
    "answer": 3,
    "explain": "`let a = 20` creates a new binding in TDZ inside the IIFE. Accessing it before declaration throws ReferenceError.",
    "difficulty": "hard"
  },
  {
    "id": 72,
    "question": "What will happen?",
    "code": "if (true) {\n  console.log(x);\n  var x = 5;\n}",
    "options": [
      "undefined",
      "5",
      "ReferenceError",
      "TypeError"
    ],
    "answer": 0,
    "explain": "var is function-scoped, not block-scoped, so x is hoisted to function/global scope with value undefined.",
    "difficulty": "easy"
  },
  {
    "id": 73,
    "question": "What happens here?",
    "code": "if (true) {\n  console.log(x);\n  let x = 5;\n}",
    "options": [
      "undefined",
      "5",
      "ReferenceError",
      "TypeError"
    ],
    "answer": 2,
    "explain": "let is block-scoped and has a TDZ until declared, so accessing before initialization throws ReferenceError.",
    "difficulty": "medium"
  },
  {
    "id": 74,
    "question": "What is the output?",
    "code": "function test() {\n  console.log(a);\n  a = 10;\n  console.log(a);\n  var a;\n}\ntest();",
    "options": [
      "undefined, 10",
      "ReferenceError",
      "10, 10",
      "undefined, undefined"
    ],
    "answer": 0,
    "explain": "var a is hoisted as undefined. After assignment, it becomes 10 within the same scope.",
    "difficulty": "medium"
  },
  {
    "id": 75,
    "question": "What is logged here?",
    "code": "var a = 1;\nfunction outer() {\n  console.log(a);\n  var a = 2;\n  function inner() { console.log(a); }\n  inner();\n}\nouter();",
    "options": [
      "1, 2",
      "undefined, 2",
      "2, 2",
      "ReferenceError"
    ],
    "answer": 1,
    "explain": "Inside outer, var a is hoisted (undefined), shadowing global a. Then assigned 2, so inner() logs 2.",
    "difficulty": "hard"
  },
  {
    "id": 76,
    "question": "What gets printed?",
    "code": "console.log(foo);\nvar foo = 1;\nfunction foo() {}\nconsole.log(foo);",
    "options": [
      "function foo() {}, 1",
      "undefined, 1",
      "1, 1",
      "Error"
    ],
    "answer": 0,
    "explain": "Function declarations are hoisted before vars. First log prints the function, then reassignment to 1.",
    "difficulty": "hard"
  },
  {
    "id": 77,
    "question": "What is the result of this code?",
    "code": "function hoistExample() {\n  console.log(x);\n  var x = 7;\n  console.log(y);\n  let y = 8;\n}\nhoistExample();",
    "options": [
      "undefined, 8",
      "undefined, ReferenceError",
      "ReferenceError, undefined",
      "Error"
    ],
    "answer": 1,
    "explain": "x is hoisted as undefined, but y is in TDZ until declared, causing ReferenceError on access.",
    "difficulty": "medium"
  },
  {
    "id": 78,
    "question": "What happens here?",
    "code": "function foo() {\n  bar();\n  var bar = function() { console.log('bar'); };\n}\nfoo();",
    "options": [
      "'bar'",
      "TypeError",
      "ReferenceError",
      "undefined"
    ],
    "answer": 1,
    "explain": "bar is hoisted as undefined. Itâ€™s not yet a function when called, so TypeError: bar is not a function.",
    "difficulty": "medium"
  },
  {
    "id": 79,
    "question": "What will this code log?",
    "code": "var a = 1;\n(function() {\n  console.log(a);\n  var a = 2;\n})();",
    "options": [
      "1",
      "2",
      "undefined",
      "ReferenceError"
    ],
    "answer": 2,
    "explain": "The inner var a is hoisted as undefined, shadowing the outer variable.",
    "difficulty": "medium"
  },
  {
    "id": 80,
    "question": "What is printed?",
    "code": "console.log(x);\nvar x = 1;\nfunction x() {}\nconsole.log(x);",
    "options": [
      "function x() {}, 1",
      "undefined, 1",
      "1, 1",
      "Error"
    ],
    "answer": 0,
    "explain": "Function declarations hoist before vars, so x initially refers to the function, later reassigned to 1.",
    "difficulty": "hard"
  }, {
    "id": 81,
    "question": "What gets logged?",
    "code": "var a = 10;\nfunction test() {\n  console.log(a);\n}\ntest();",
    "options": [
      "10",
      "undefined",
      "ReferenceError",
      "null"
    ],
    "answer": 0,
    "explain": "Functions can access variables from their outer (global) lexical scope. `a` is resolved from the global scope.",
    "difficulty": "easy"
  },
  {
    "id": 82,
    "question": "What is printed?",
    "code": "function foo() {\n  var a = 20;\n  function bar() {\n    console.log(a);\n  }\n  bar();\n}\nfoo();",
    "options": [
      "20",
      "undefined",
      "ReferenceError",
      "Error"
    ],
    "answer": 0,
    "explain": "Lexical scoping means inner functions have access to variables defined in their outer scope â€” even after execution context changes.",
    "difficulty": "easy"
  },
  {
    "id": 83,
    "question": "What gets logged?",
    "code": "var a = 1;\nfunction outer() {\n  var a = 2;\n  function inner() {\n    console.log(a);\n  }\n  return inner;\n}\nconst fn = outer();\nfn();",
    "options": [
      "1",
      "2",
      "undefined",
      "ReferenceError"
    ],
    "answer": 1,
    "explain": "Inner functions use the value of variables from their lexical (definition) environment, not where they are called.",
    "difficulty": "medium"
  },
  {
    "id": 84,
    "question": "What happens here?",
    "code": "if (true) {\n  var x = 5;\n}\nconsole.log(x);",
    "options": [
      "undefined",
      "5",
      "ReferenceError",
      "Error"
    ],
    "answer": 1,
    "explain": "`var` is function-scoped, not block-scoped. The variable is hoisted to the enclosing (global) scope.",
    "difficulty": "easy"
  },
  {
    "id": 85,
    "question": "What is printed?",
    "code": "if (true) {\n  let y = 10;\n}\nconsole.log(y);",
    "options": [
      "10",
      "undefined",
      "ReferenceError",
      "null"
    ],
    "answer": 2,
    "explain": "`let` and `const` are block-scoped. They exist only inside the block `{}`.",
    "difficulty": "medium"
  },
  {
    "id": 86,
    "question": "What is logged?",
    "code": "let a = 1;\nfunction test() {\n  let a = 2;\n  if (true) {\n    let a = 3;\n    console.log(a);\n  }\n  console.log(a);\n}\ntest();\nconsole.log(a);",
    "options": [
      "3, 2, 1",
      "1, 2, 3",
      "3, 3, 3",
      "undefined, 2, 1"
    ],
    "answer": 0,
    "explain": "Each `let` creates a new binding per scope. The innermost block logs 3, function scope logs 2, global logs 1.",
    "difficulty": "medium"
  },
  {
    "id": 87,
    "question": "What will be printed?",
    "code": "let x = 10;\nfunction outer() {\n  let x = 20;\n  function inner() {\n    console.log(x);\n  }\n  inner();\n}\nouter();",
    "options": [
      "10",
      "20",
      "undefined",
      "ReferenceError"
    ],
    "answer": 1,
    "explain": "Inner uses variable from outerâ€™s lexical environment â€” not the global one.",
    "difficulty": "easy"
  },
  {
    "id": 88,
    "question": "What is logged?",
    "code": "function test() {\n  if (true) {\n    var a = 1;\n    let b = 2;\n  }\n  console.log(a);\n  console.log(b);\n}\ntest();",
    "options": [
      "1, ReferenceError",
      "1, 2",
      "undefined, undefined",
      "ReferenceError, ReferenceError"
    ],
    "answer": 0,
    "explain": "`a` (var) is function-scoped and available. `b` (let) is block-scoped â€” inaccessible outside block.",
    "difficulty": "medium"
  },
  {
    "id": 89,
    "question": "What gets printed?",
    "code": "var x = 1;\nfunction a() {\n  var x = 2;\n  function b() {\n    console.log(x);\n  }\n  b();\n}\na();",
    "options": [
      "1",
      "2",
      "undefined",
      "ReferenceError"
    ],
    "answer": 1,
    "explain": "Function `b` is lexically inside `a`, so it accesses the `x` from `a`'s scope, not the global one.",
    "difficulty": "medium"
  },
  {
    "id": 90,
    "question": "What happens here?",
    "code": "function f1() {\n  var a = 10;\n  f2();\n}\nfunction f2() {\n  console.log(a);\n}\nf1();",
    "options": [
      "10",
      "undefined",
      "ReferenceError",
      "Error"
    ],
    "answer": 2,
    "explain": "`a` is not in f2â€™s lexical scope. Lexical scoping depends on where functions are defined, not called.",
    "difficulty": "medium"
  },
  {
    "id": 91,
    "question": "What is the output?",
    "code": "let x = 'global';\nfunction outer() {\n  let x = 'outer';\n  function inner() {\n    console.log(x);\n  }\n  return inner;\n}\nconst fn = outer();\nfn();",
    "options": [
      "'global'",
      "'outer'",
      "undefined",
      "ReferenceError"
    ],
    "answer": 1,
    "explain": "Closures retain lexical access to variables from where they were defined â€” not where theyâ€™re called.",
    "difficulty": "medium"
  },
  {
    "id": 92,
    "question": "What is printed here?",
    "code": "function foo() {\n  let a = 1;\n  {\n    let a = 2;\n    {\n      let a = 3;\n      console.log(a);\n    }\n    console.log(a);\n  }\n  console.log(a);\n}\nfoo();",
    "options": [
      "3, 2, 1",
      "1, 2, 3",
      "3, 3, 3",
      "undefined"
    ],
    "answer": 0,
    "explain": "Each block has its own scope with a new `a`. Closest binding is used when referenced.",
    "difficulty": "medium"
  },
  {
    "id": 93,
    "question": "What happens here?",
    "code": "let a = 10;\nfunction test() {\n  console.log(a);\n  let a = 20;\n}\ntest();",
    "options": [
      "10",
      "20",
      "undefined",
      "ReferenceError"
    ],
    "answer": 3,
    "explain": "Inside `test`, `a` is redeclared using `let`. The variable is in TDZ until the declaration line.",
    "difficulty": "hard"
  },
  {
    "id": 94,
    "question": "What will be the output?",
    "code": "var a = 1;\nfunction one() {\n  var a = 2;\n  function two() {\n    console.log(a);\n  }\n  return two;\n}\nconst f = one();\nf();",
    "options": [
      "1",
      "2",
      "undefined",
      "Error"
    ],
    "answer": 1,
    "explain": "Lexical scoping ensures that `two` accesses `a` from `one`â€™s scope (2), not the global (1).",
    "difficulty": "medium"
  },
  {
    "id": 95,
    "question": "What is logged?",
    "code": "if (true) {\n  const PI = 3.14;\n  console.log(PI);\n}\nconsole.log(typeof PI);",
    "options": [
      "3.14, undefined",
      "3.14, number",
      "undefined, undefined",
      "Error"
    ],
    "answer": 0,
    "explain": "`PI` is block-scoped. Inside block logs 3.14, outside itâ€™s not defined â†’ typeof PI is 'undefined'.",
    "difficulty": "easy"
  },
  {
    "id": 96,
    "question": "What gets logged?",
    "code": "let globalVar = 'G';\nfunction a() {\n  let outerVar = 'O';\n  function b() {\n    let innerVar = 'I';\n    console.log(globalVar, outerVar, innerVar);\n  }\n  b();\n}\na();",
    "options": [
      "'G O I'",
      "'G G G'",
      "'undefined undefined undefined'",
      "Error"
    ],
    "answer": 0,
    "explain": "Lexical scope chain: inner â†’ outer â†’ global. All are accessible in order.",
    "difficulty": "easy"
  },
  {
    "id": 97,
    "question": "What happens here?",
    "code": "function foo() {\n  console.log(x);\n  var x = 10;\n  if (true) {\n    let x = 20;\n    console.log(x);\n  }\n}\nfoo();",
    "options": [
      "undefined, 20",
      "10, 20",
      "undefined, undefined",
      "ReferenceError"
    ],
    "answer": 0,
    "explain": "`var x` is hoisted and initialized as undefined; inside block, new `x` (let) shadows it.",
    "difficulty": "hard"
  },
  {
    "id": 98,
    "question": "What gets printed?",
    "code": "var a = 1;\nfunction f() {\n  console.log(a);\n}\nfunction g() {\n  var a = 2;\n  f();\n}\ng();",
    "options": [
      "1",
      "2",
      "undefined",
      "ReferenceError"
    ],
    "answer": 0,
    "explain": "fâ€™s scope is determined by where it was defined (global), not where called (inside g).",
    "difficulty": "medium"
  },
  {
    "id": 99,
    "question": "What is printed?",
    "code": "{ let x = 5; { let x = 10; console.log(x); } console.log(x); }",
    "options": [
      "10, 5",
      "5, 10",
      "10, 10",
      "undefined"
    ],
    "answer": 0,
    "explain": "Inner block creates a new scope shadowing outer variable. Closest declaration is used.",
    "difficulty": "easy"
  },
  {
    "id": 100,
    "question": "What is printed?",
    "code": "let a = 'global';\nfunction outer() {\n  let a = 'outer';\n  function inner() {\n    let a = 'inner';\n    console.log(a);\n  }\n  inner();\n  console.log(a);\n}\nouter();\nconsole.log(a);",
    "options": [
      "'inner', 'outer', 'global'",
      "'global', 'outer', 'inner'",
      "'outer', 'inner', 'global'",
      "'inner', 'global', 'outer'"
    ],
    "answer": 0,
    "explain": "Each scope shadows the previous one. The innermost has priority when accessed.",
    "difficulty": "easy"
  },{
    "id": 101,
    "question": "What will this print and why (implicit binding)?",
    "code": "const obj = {\n name: 'Alice',\n greet() { console.log(this.name); }\n};\nobj.greet();",
    "options": [
    "'Alice'",
    "undefined",
    "ReferenceError",
    "Error"
    ],
    "answer": 0,
    "explain": "Implicit binding: when a function is called as a property of an object, this refers to that object (obj).",
    "difficulty": "easy"
    },
    {
    "id": 102,
    "question": "What does this log (explicit binding with call)?",
    "code": "function say() { console.log(this.msg); }\nconst a = { msg: 'Hello' };\nsay.call(a);",
    "options": [
    "'Hello'",
    "undefined",
    "TypeError",
    "ReferenceError"
    ],
    "answer": 0,
    "explain": "Using call, we explicitly set this to a, so this.msg is 'Hello'.",
    "difficulty": "easy"
    },
    {
    "id": 103,
    "question": "What will this produce (apply vs call)?",
    "code": "function add(a, b) { return a + b + this.c; }\nconst obj = { c: 1 };\nconsole.log(add.apply(obj, [2, 3]));\nconsole.log(add.call(obj, 2, 3));",
    "options": [
    "6 and 6",
    "6 and undefined",
    "NaN and NaN",
    "Error and Error"
    ],
    "answer": 0,
    "explain": "apply takes args array, call takes args list; both set this to obj: 2+3+1 = 6.",
    "difficulty": "easy"
    },
    {
    "id": 104,
    "question": "What is logged (bind creates a new function)?",
    "code": "function mul(x) { return x * this.factor; }\nconst obj = { factor: 3 };\nconst f = mul.bind(obj);\nconsole.log(f(5));",
    "options": [
    "15",
    "5",
    "NaN",
    "undefined"
    ],
    "answer": 0,
    "explain": "bind returns a new function with this permanently set to obj, so 53 = 15.",
    "difficulty": "easy"
    },
    {
    "id": 105,
    "question": "Which this does an arrow function use here?",
    "code": "const obj = {\n val: 10,\n arrow: () => console.log(this.val),\n regular() { console.log(this.val); }\n};\nobj.arrow();\nobj.regular();",
    "options": [
    "undefined, 10",
    "10, undefined",
    "10, 10",
    "undefined, undefined"
    ],
    "answer": 0,
    "explain": "Arrow functions use lexical this (here outer scope â€” likely undefined in strict/module). Regular method uses obj as this.",
    "difficulty": "medium"
    },
    {
    "id": 106,
    "question": "What is output (new binding)?",
    "code": "function Person(name) { this.name = name; }\nconst p = new Person('Bob');\nconsole.log(p.name);",
    "options": [
    "'Bob'",
    "undefined",
    "ReferenceError",
    "Error"
    ],
    "answer": 0,
    "explain": "When called with new, this refers to the newly created instance; property assignment sets p.name.",
    "difficulty": "easy"
    },
    {
    "id": 107,
    "question": "What does this print (explicit binding cannot be overruled by new when bound)?",
    "code": "function F() { this.x = 1; }\nconst o = { x: 2 };\nconst B = F.bind(o);\nconst inst = new B();\nconsole.log(o.x, inst.x);",
    "options": [
    "2, 1",
    "2, undefined",
    "1, 1",
    "2, 2"
    ],
    "answer": 0,
    "explain": "When a bound function is used with new, the binding to an object is ignored for this in many engines; the new instance gets its own this and sets x=1; the original object stays x=2. (Behavior: bound function when used with new creates instance but original bound obj unaffected.)",
    "difficulty": "hard"
    },
    {
    "id": 108,
    "question": "What is logged (call on method extraction)?",
    "code": "const o = { v: 5, get() { return this.v; } };\nconst g = o.get;\nconsole.log(g());\nconsole.log(g.call(o));",
    "options": [
    "undefined, 5",
    "5, 5",
    "undefined, undefined",
    "Error, 5"
    ],
    "answer": 0,
    "explain": "Extracted method called standalone has default this (undefined in strict). Using call sets this to o and returns 5.",
    "difficulty": "medium"
    },
    {
    "id": 109,
    "question": "Which this is used inside setTimeout callback in this code?",
    "code": "const user = {\n name: 'X',\n greet() { setTimeout(function() { console.log(this.name); }, 0); }\n};\nuser.greet();",
    "options": [
    "undefined",
    "'X'",
    "ReferenceError",
    "Error"
    ],
    "answer": 0,
    "explain": "Regular function in setTimeout has its own this (global/undefined). To preserve user, use arrow function or bind.",
    "difficulty": "medium"
    },
    {
    "id": 110,
    "question": "What will be printed (arrow preserving this)?",
    "code": "const user = {\n name: 'Y',\n greet() { setTimeout(() => console.log(this.name), 0); }\n};\nuser.greet();",
    "options": [
    "'Y'",
    "undefined",
    "Error",
    "ReferenceError"
    ],
    "answer": 0,
    "explain": "Arrow uses the lexical this of greet, which is user, so it prints 'Y'.",
    "difficulty": "easy"
    },
    {
    "id": 111,
    "question": "Which binding rule applies when using call on a bound function?",
    "code": "function foo() { console.log(this.a); }\nconst o = { a: 1 };\nconst b = { a: 2 };\nconst bf = foo.bind(o);\nbf.call(b);",
    "options": [
    "bound this (o) is used, call ignored",
    "call overrides bind, so b is used",
    "throws TypeError",
    "undefined"
    ],
    "answer": 0,
    "explain": "A function permanently bound by bind keeps its bound this; calling with call does not override it.",
    "difficulty": "hard"
    },
    {
    "id": 112,
    "question": "What is logged when using class methods and arrow functions?",
    "code": "class C { constructor(){ this.x = 1 } method() { return this.x } arrow = () => this.x }\nconst c = new C(); const m = c.method; console.log(m()); console.log(c.arrow());",
    "options": [
    "undefined, 1",
    "1, 1",
    "undefined, undefined",
    "Error, 1"
    ],
    "answer": 0,
    "explain": "Extracted class method loses this (undefined). The arrow property is defined on instance and uses lexical this set at construction, so returns 1.",
    "difficulty": "hard"
    },
    {
    "id": 113,
    "question": "What will be printed (function used as constructor without new)?",
    "code": "function Thing() { this.x = 10; }\nThing();\nconsole.log(typeof x);",
    "options": [
    "number",
    "undefined",
    "ReferenceError",
    "object"
    ],
    "answer": 0,
    "explain": "Calling constructor function without new assigns this to global (or undefined in strict). Here assuming non-strict, it creates global x=10, so typeof x is 'number'.",
    "difficulty": "hard"
    },
    {
    "id": 114,
    "question": "Which is true about arrow functions and new?",
    "code": "const A = () => {};\ntry { new A(); console.log('constructed'); } catch(e) { console.log('error'); }",
    "options": [
    "'constructed'",
    "'error'",
    "undefined",
    "TypeError thrown earlier"
    ],
    "answer": 1,
    "explain": "Arrow functions are not constructible; attempting new on an arrow function throws a TypeError (caught and prints 'error').",
    "difficulty": "easy"
    },
    {
    "id": 115,
    "question": "What is the output (method borrowed between objects)?",
    "code": "const a = { name: 'A', greet() { return this.name } };\nconst b = { name: 'B' };\nb.greet = a.greet;\nconsole.log(b.greet());",
    "options": [
    "'A'",
    "'B'",
    "undefined",
    "Error"
    ],
    "answer": 1,
    "explain": "When method is assigned to b and called as b.greet(), this is b, so returns 'B'.",
    "difficulty": "easy"
    },
    {
    "id": 116,
    "question": "What does this code demonstrate about this in nested objects?",
    "code": "const outer = { name: 'O', inner: { name: 'I', get() { return this.name } } };\nconsole.log(outer.inner.get());",
    "options": [
    "'I'",
    "'O'",
    "undefined",
    "Error"
    ],
    "answer": 0,
    "explain": "Implicit binding uses the immediate object (inner) before dot-call, so this refers to inner (name 'I').",
    "difficulty": "easy"
    },
    {
    "id": 117,
    "question": "What is logged (function borrowing + call)?",
    "code": "function show() { return this.x }\nconst o = { x: 9 };\nconsole.log(show.call(o));",
    "options": [
    "9",
    "undefined",
    "Error",
    "null"
    ],
    "answer": 0,
    "explain": "Explicit binding with call sets this to o, so returns 9.",
    "difficulty": "easy"
    },
    {
    "id": 118,
    "question": "Which this is used for a function defined in global scope called as callback?",
    "code": "function cb() { console.log(this); }\nsetTimeout(cb, 0);",
    "options": [
    "global or undefined",
    "caller object",
    "setTimeout internal object",
    "the window variable always"
    ],
    "answer": 0,
    "explain": "Callbacks invoked by timers are called as plain functions; this is undefined in strict or global object in non-strict contexts.",
    "difficulty": "medium"
    },
    {
    "id": 119,
    "question": "What is printed (combination of bind and arrow)?",
    "code": "const obj = { v: 1 };\nfunction f() { return () => this.v; }\nconst bound = f.bind(obj);\nconsole.log(bound()());",
    "options": [
    "1",
    "undefined",
    "Error",
    "null"
    ],
    "answer": 0,
    "explain": "bind sets this for f to obj. The returned arrow uses lexical this from f, so it returns obj.v (1).",
    "difficulty": "hard"
    },
    {
    "id": 120,
    "question": "Which of the following best summarizes this binding precedence?",
    "code": "",
    "options": [
    "new > explicit (bind/call/apply) > implicit > default",
    "implicit > explicit > new > default",
    "explicit > new > implicit > default",
    "default > implicit > explicit > new"
    ],
    "answer": 0,
    "explain": "Order: new creates a brand-new object (highest), explicit binding (bind/call/apply) follows (note: bind when used with new is special), implicit is next, default (global/undefined) is last.",
    "difficulty": "hard"
    },
    {
    "id": 121,
    "question": "What prints first and why (callbacks & timers)?",
    "code": "console.log('start');\nsetTimeout(() => console.log('timeout'), 0);\nconsole.log('end');",
    "options": [
    "start, end, timeout",
    "start, timeout, end",
    "timeout, start, end",
    "end, start, timeout"
    ],
    "answer": 0,
    "explain": "setTimeout callback is scheduled as a macrotask; synchronous code runs first. So 'start' and 'end' print, then later the macrotask runs.",
    "difficulty": "easy"
    },
    {
    "id": 122,
    "question": "What is the console order (microtasks vs macrotasks)?",
    "code": "console.log('1');\nPromise.resolve().then(() => console.log('2'));\nconsole.log('3');",
    "options": [
    "1, 3, 2",
    "1, 2, 3",
    "2, 1, 3",
    "3, 1, 2"
    ],
    "answer": 0,
    "explain": "Promise.then schedules a microtask that runs after current stack, so synchronous logs 1 and 3 first, then microtask logs 2.",
    "difficulty": "easy"
    },
    {
    "id": 123,
    "question": "What will this log (promise chaining)?",
    "code": "Promise.resolve()\n .then(() => { console.log('a'); return Promise.resolve('b'); })\n .then(x => console.log(x));",
    "options": [
    "a, b",
    "b, a",
    "a, undefined",
    "undefined, b"
    ],
    "answer": 0,
    "explain": "First then logs 'a' and returns a resolved promise with 'b', next then receives 'b' and logs it.",
    "difficulty": "easy"
    },
    {
    "id": 124,
    "question": "What happens with this rejected promise and no catch?",
    "code": "Promise.reject(new Error('fail'));\n// no catch attached",
    "options": [
    "UnhandledPromiseRejection (may warn) but code continues",
    "Throws synchronously and halts execution",
    "Nothing happens",
    "It becomes resolved automatically"
    ],
    "answer": 0,
    "explain": "An unhandled rejected Promise may trigger an unhandled rejection warning/event but not a synchronous throw; behavior depends on environment.",
    "difficulty": "medium"
    },
    {
    "id": 125,
    "question": "What will be printed (async/await flow)?",
    "code": "async function f(){ console.log('a'); await null; console.log('b'); }\nconsole.log('start');\nf();\nconsole.log('end');",
    "options": [
    "start, a, end, b",
    "start, a, b, end",
    "a, start, end, b",
    "start, end, a, b"
    ],
    "answer": 0,
    "explain": "async function runs synchronously until first await (logs 'a'), then yields; current stack prints 'end', then microtask runs and logs 'b'.",
    "difficulty": "medium"
    },
    {
    "id": 126,
    "question": "How to convert a callback-based API to Promise style?",
    "code": "function read(cb) { setTimeout(() => cb(null, 'data'), 100); }\n// what to return to create a promise wrapper?",
    "options": [
    "return new Promise((res, rej) => read((err, d) => err ? rej(err) : res(d)));",
    "return Promise.resolve(read());",
    "return read();",
    "return async read();"
    ],
    "answer": 0,
    "explain": "Use the Promise constructor and call the callback to resolve or reject appropriately.",
    "difficulty": "medium"
    },
    {
    "id": 127,
    "question": "What does Promise.all do when one promise rejects?",
    "code": "Promise.all([Promise.resolve(1), Promise.reject('err')])\n .then(x => console.log('then', x))\n .catch(e => console.log('catch', e));",
    "options": [
    "catch 'err' executes, aggregate rejected",
    "then runs with partial results",
    "never resolves nor rejects",
    "silently ignores the rejection"
    ],
    "answer": 0,
    "explain": "Promise.all rejects immediately with the first rejection; the catch logs the rejection reason.",
    "difficulty": "easy"
    },
    {
    "id": 128,
    "question": "What is printed (Promise.resolve in setTimeout)?",
    "code": "setTimeout(() => Promise.resolve().then(() => console.log('micro in macrotask')), 0);\nPromise.resolve().then(() => console.log('micro'));\nconsole.log('sync');",
    "options": [
    "sync, micro, micro in macrotask",
    "sync, micro in macrotask, micro",
    "micro, sync, micro in macrotask",
    "sync, micro in macrotask, micro in macrotask"
    ],
    "answer": 0,
    "explain": "Synchronous runs first. Initial microtask runs next. Later, macrotask runs and schedules its microtask, which runs after that macrotask.",
    "difficulty": "hard"
    },
    {
    "id": 129,
    "question": "What will be output (async error handling)?",
    "code": "async function f(){ throw new Error('fail'); }\nf().catch(e => console.log('caught'));",
    "options": [
    "caught",
    "uncaught error",
    "nothing",
    "throws synchronously"
    ],
    "answer": 0,
    "explain": "Thrown error inside async function rejects the returned promise; catch handles it and logs 'caught'.",
    "difficulty": "easy"
    },
    {
    "id": 130,
    "question": "Which pattern correctly handles sequential async operations with await?",
    "code": "async function seq() {\n const a = await p1();\n const b = await p2(a);\n return b;\n}",
    "options": [
    "This runs p1 then p2 in sequence",
    "This runs p1 and p2 in parallel",
    "This throws immediately",
    "This returns a synchronous result"
    ],
    "answer": 0,
    "explain": "await forces sequential execution: p1 completes before p2 starts.",
    "difficulty": "easy"
    },
    {
    "id": 131,
    "question": "What is printed (Promise.race)?",
    "code": "Promise.race([new Promise(r=>setTimeout(()=>r('a'),50)), new Promise(r=>setTimeout(()=>r('b'),10))])\n .then(x => console.log(x));",
    "options": [
    "'b'",
    "'a'",
    "undefined",
    "Error"
    ],
    "answer": 0,
    "explain": "Promise.race resolves/rejects with the first settled promise â€” here 'b' resolves faster.",
    "difficulty": "medium"
    },
    {
    "id": 132,
    "question": "What will run first when using async functions and microtasks?",
    "code": "async function a(){ await 0; console.log('a'); }\nasync function b(){ console.log('b'); }\nconsole.log('start');\na();\nb();",
    "options": [
    "start, b, a",
    "start, a, b",
    "b, start, a",
    "start, a, b or engine dependent"
    ],
    "answer": 0,
    "explain": "b runs synchronously (no await). a logs after await as a microtask. So order: start, b, a.",
    "difficulty": "hard"
    },
    {
    "id": 133,
    "question": "How to catch both synchronous and asynchronous errors using try/catch with async/await?",
    "code": "async function example(){ try { await mightReject(); } catch(e) { console.log('caught'); } }",
    "options": [
    "Use try/catch around await, it handles both async rejections and synchronous throws inside try",
    "try/catch can't catch async rejections",
    "Use .catch only",
    "Wrap with setTimeout"
    ],
    "answer": 0,
    "explain": "try/catch around await catches promise rejections and synchronous exceptions inside the try block.",
    "difficulty": "medium"
    },
    {
    "id": 134,
    "question": "What does async function return?",
    "code": "async function f() { return 1; }\nconsole.log(f());",
    "options": [
    "Promise resolving to 1",
    "1",
    "undefined",
    "Error"
    ],
    "answer": 0,
    "explain": "Async functions always return a Promise which resolves with the returned value.",
    "difficulty": "easy"
    },
    {
    "id": 135,
    "question": "What is printed by this Promise chain with then returning a value vs returning a promise?",
    "code": "Promise.resolve(1)\n .then(x => x + 1)\n .then(x => Promise.resolve(x + 1))\n .then(x => console.log(x));",
    "options": [
    "3",
    "2",
    "4",
    "undefined"
    ],
    "answer": 0,
    "explain": "First then returns 2, next then returns a promise resolving to 3, final then logs 3.",
    "difficulty": "medium"
    },
    {
    "id": 136,
    "question": "What will be logged (error propagation in promises)?",
    "code": "Promise.resolve()\n .then(() => { throw 'err'; })\n .then(() => console.log('ok'))\n .catch(e => console.log('caught', e));",
    "options": [
    "caught err",
    "ok",
    "uncaught error",
    "nothing"
    ],
    "answer": 0,
    "explain": "Throw inside then rejects the promise; downstream catch handles it and logs the error.",
    "difficulty": "easy"
    },
    {
    "id": 137,
    "question": "What does this demonstrate (parallel vs sequential)?",
    "code": "const p1 = () => new Promise(r => setTimeout(() => r(1), 50));\nconst p2 = () => new Promise(r => setTimeout(() => r(2), 50));\nawait Promise.all([p1(), p2()]);",
    "options": [
    "p1 and p2 run in parallel",
    "p1 then p2 sequentially",
    "Only p1 runs",
    "Only p2 runs"
    ],
    "answer": 0,
    "explain": "Promise.all takes started promises and waits for all; starting p1() and p2() before awaiting runs them in parallel.",
    "difficulty": "medium"
    },
    {
    "id": 138,
    "question": "What is returned when awaiting a non-promise value?",
    "code": "async function x(){ return await 5; }\nx().then(v => console.log(v));",
    "options": [
    "5",
    "undefined",
    "Promise {5}",
    "Error"
    ],
    "answer": 0,
    "explain": "await coerces non-promise values to resolved promises; awaiting 5 yields 5.",
    "difficulty": "easy"
    },
    {
    "id": 139,
    "question": "Which of these converts callback-style into Promise-based (promisify)?",
    "code": "function promisify(fn){ return function(...args){ return new Promise((res, rej) => fn(...args, (err, val) => err ? rej(err) : res(val))); } }",
    "options": [
    "Correct promisify implementation",
    "Incorrect, ignores this binding",
    "Incorrect, doesn't return a function",
    "Incorrect, uses setTimeout incorrectly"
    ],
    "answer": 1,
    "explain": "While the structure is correct for many callbacks, it ignores this binding; proper promisify should preserve this using function.apply or arrow that calls fn.call(this,...).",
    "difficulty": "hard"
    },
    {
    "id": 140,
    "question": "What will console.log show for this chained async/await snippet?",
    "code": "async function a(){ return 'A' }\nasync function b(){ return a() + 'B' }\nb().then(x => console.log(x));",
    "options": [
    "'AB'",
    "'A[object Promise]B'",
    "Error",
    "undefined"
    ],
    "answer": 0,
    "explain": "Calling a() returns a promise; using + with a promise coerces to string? Actually a() resolves to 'A' before b returns because await is not used â€” but JS will coerce promise to string producing '[object Promise]'. However since a() returns a Promise and b returns a() + 'B' which concatenates Promise to string, result becomes '[object Promise]B'. To avoid confusion: correct behavior is '[object Promise]B'.",
    "difficulty": "hard"
    },
    {
    "id": 141,
    "question": "Which is a concise arrow function that returns squared value?",
    "code": "const sq = x => x * x; console.log(sq(3));",
    "options": [
    "9",
    "undefined",
    "TypeError",
    "Error"
    ],
    "answer": 0,
    "explain": "Arrow expression returns xx implicitly; sq(3) = 9.",
    "difficulty": "easy"
    },
    {
    "id": 142,
    "question": "What does this destructuring produce?",
    "code": "const obj = { a: 1, b: 2 };\nconst { a, b } = obj;\nconsole.log(a, b);",
    "options": [
    "1 2",
    "undefined undefined",
    "Error",
    "2 1"
    ],
    "answer": 0,
    "explain": "Object destructuring assigns matching property values to variables a and b.",
    "difficulty": "easy"
    },
    {
    "id": 143,
    "question": "Which string results from template literal?",
    "code": "const name = 'Sam';\nconsole.log(Hello, ${name}!);",
    "options": [
    "Hello, Sam!",
    "Hello, ${name}!",
    "Error",
    "undefined"
    ],
    "answer": 0,
    "explain": "Template literals interpolate expressions inside ${}.",
    "difficulty": "easy"
    },
    {
    "id": 144,
    "question": "What does rest operator collect in this function?",
    "code": "function f(a, ...rest) { console.log(rest); }\nf(1,2,3,4);",
    "options": [
    "[2,3,4]",
    "[1,2,3,4]",
    "[]",
    "Error"
    ],
    "answer": 0,
    "explain": "...rest gathers remaining arguments into an array starting at position 1.",
    "difficulty": "easy"
    },
    {
    "id": 145,
    "question": "What is the result of spreading arrays into a new array?",
    "code": "const a = [1,2]; const b = [...a,3]; console.log(b);",
    "options": [
    "[1,2,3]",
    "[[1,2],3]",
    "Error",
    "undefined"
    ],
    "answer": 0,
    "explain": "Spread expands elements of a into the new array.",
    "difficulty": "easy"
    },
    {
    "id": 146,
    "question": "What does this module-style export imply (ES modules)?",
    "code": "export function f() { return 1 }\n// in another file: import { f } from './mod'; console.log(f());",
    "options": [
    "f is a named export and can be imported by name",
    "f is default export",
    "Cannot import f",
    "f is private"
    ],
    "answer": 0,
    "explain": "Named exports are imported using curly braces with the same name.",
    "difficulty": "medium"
    },
    {
    "id": 147,
    "question": "Which is true about default exports?",
    "code": "export default function() { return 'x' }\n// import fn from './mod';",
    "options": [
    "Default export can be imported with any name",
    "Default export must use its original name",
    "Default export cannot be a function",
    "Default export creates multiple bindings"
    ],
    "answer": 0,
    "explain": "Default exports provide a single value and can be imported with any local name.",
    "difficulty": "easy"
    },
    {
    "id": 148,
    "question": "What is the output (destructuring nested)?",
    "code": "const data = { a: { b: 2 } };\nconst { a: { b } } = data;\nconsole.log(b);",
    "options": [
    "2",
    "undefined",
    "Error",
    "null"
    ],
    "answer": 0,
    "explain": "Nested destructuring accesses deep properties directly into variables.",
    "difficulty": "medium"
    },
    {
    "id": 149,
    "question": "What will be logged (default param + destructuring)?",
    "code": "function f({x = 1, y = 2} = {}) { console.log(x, y); }\nf({x: 3});",
    "options": [
    "3 2",
    "1 2",
    "3 undefined",
    "undefined undefined"
    ],
    "answer": 0,
    "explain": "x is overridden by provided value 3; y uses default 2 since not provided.",
    "difficulty": "medium"
    },
    {
    "id": 150,
    "question": "What does this do (shallow clone via spread)?",
    "code": "const o = { a: 1, b: { c: 2 } };\nconst clone = { ...o };\nconsole.log(clone.b === o.b);",
    "options": [
    "true",
    "false",
    "undefined",
    "Error"
    ],
    "answer": 0,
    "explain": "Spread performs a shallow copy: nested object references are copied, not deep-cloned.",
    "difficulty": "medium"
    },
    {
    "id": 151,
    "question": "Which arrow function syntax returns an object literal correctly?",
    "code": "const f = () => ({ a: 1 }); console.log(f());",
    "options": [
    "{ a: 1 }",
    "undefined",
    "Error",
    "() => { a: 1 }"
    ],
    "answer": 0,
    "explain": "To return an object literal implicitly you must wrap it in parentheses to avoid confusion with function body.",
    "difficulty": "easy"
    },
    {
    "id": 152,
    "question": "What is result of destructuring an array?",
    "code": "const [x, , z] = [1,2,3]; console.log(x, z);",
    "options": [
    "1 3",
    "1 2",
    "undefined undefined",
    "Error"
    ],
    "answer": 0,
    "explain": "Array destructuring assigns by position; skipping via empty slot picks element 3 into z.",
    "difficulty": "easy"
    },
    {
    "id": 153,
    "question": "What is logged (template literal with expression)?",
    "code": "const a = 2; const b = 3; console.log(sum=${a+b});",
    "options": [
    "sum=5",
    "sum=${a+b}",
    "sum=23",
    "undefined"
    ],
    "answer": 0,
    "explain": "Expressions inside template literals are evaluated; a+b is 5.",
    "difficulty": "easy"
    },
    {
    "id": 154,
    "question": "Which of these imports would import the default export and a named export?",
    "code": "// module: export default X; export const Y = 2;\n// import ??? from './m';",
    "options": [
    "import X, { Y } from './m';",
    "import { X, Y } from './m';",
    "import { default as X } from './m';",
    "import * as all from './m';"
    ],
    "answer": 0,
    "explain": "Syntax import DefaultName, { named } from '...' imports a default and named export together.",
    "difficulty": "medium"
    },
    {
    "id": 155,
    "question": "What does Object.assign do in this example?",
    "code": "const t = { a:1 };\nconst u = Object.assign({}, t, { b:2 });\nconsole.log(u);",
    "options": [
    "{ a:1, b:2 }",
    "{ a:1 }",
    "Error",
    "undefined"
    ],
    "answer": 0,
    "explain": "Object.assign copies enumerable own properties from source objects into the target object (here cloning t and adding b).",
    "difficulty": "easy"
    },
    {
    "id": 156,
    "question": "What is logged (default param with destructured rest)?",
    "code": "function f({a, ...rest}) { console.log(a, rest); }\nf({a:1,b:2,c:3});",
    "options": [
    "1 { b:2, c:3 }",
    "1 undefined",
    "Error",
    "undefined undefined"
    ],
    "answer": 0,
    "explain": "Rest in object destructuring collects remaining properties into an object.",
    "difficulty": "medium"
    },
    {
    "id": 157,
    "question": "What will be the type printed here (module vs script)?",
    "code": "// in ES module environment\nconsole.log(typeof exports);",
    "options": [
    "undefined",
    "object",
    "function",
    "Error"
    ],
    "answer": 0,
    "explain": "In native ES modules, CommonJS exports is not defined; typeof exports yields 'undefined'.",
    "difficulty": "hard"
    },
    {
    "id": 158,
    "question": "What is result of using spread with strings into arrays?",
    "code": "const chars = [...'hi']; console.log(chars);",
    "options": [
    "['h','i']",
    "['hi']",
    "Error",
    "['h i']"
    ],
    "answer": 0,
    "explain": "Strings are iterable; spread expands each character into the new array.",
    "difficulty": "easy"
    },
    {
    "id": 159,
    "question": "Which statement about ES6 modules is correct?",
    "code": "",
    "options": [
    "Module imports are live bindings (reflect updates)",
    "Imports copy values statically at import time",
    "You can conditionally import using static import syntax",
    "export and import are runtime functions"
    ],
    "answer": 0,
    "explain": "ES module imports are live read-only views (bindings) â€” updates to exported variables reflect in importers (when mutable and allowed).",
    "difficulty": "hard"
    },
    {
    "id": 160,
    "question": "What will this log (combining rest, spread and default)?",
    "code": "function f(a=1, ...rest){ console.log(a, rest); }\nconst arr = [2,3,4];\nf(...arr);",
    "options": [
    "2 [3,4]",
    "1 [2,3,4]",
    "2 [2,3,4]",
    "Error"
    ],
    "answer": 0,
    "explain": "Spread arr into arguments: a=2, rest collects remaining [3,4]. Default not used.",
    "difficulty": "medium"
    }
]
