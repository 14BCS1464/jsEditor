

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Online JavaScript Editor</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.43.0/min/vs/loader.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/js-beautify/1.14.0/beautify.min.js"></script>
  <script src="https://checkout.razorpay.com/v1/checkout.js"></script>

  <style>
    /* Modern Editor CSS with optimized space usage */
    :root {
      --primary-color: #6c5ce7;
      --secondary-color: #00cec9;
      --dark-bg: #0f0f17;
      --card-bg: #1a1a25;
      --text-primary: #f1f1f1;
      --text-secondary: #a0a0a0;
      --success: #00b894;
      --warning: #fdcb6e;
      --danger: #ff7675;
      --border-radius: 12px;
      --shadow-sm: 0 4px 6px rgba(0, 0, 0, 0.1);
      --shadow-md: 0 10px 15px rgba(0, 0, 0, 0.1);
      --shadow-lg: 0 15px 25px rgba(0, 0, 0, 0.1);
      --transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
    }

    #toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
        }

        .toast {
            min-width: 250px;
            margin-bottom: 10px;
            padding: 15px;
            border-radius: 4px;
            color: white;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            animation: slide-in 0.3s, fade-out 0.5s 2.5s forwards;
            overflow: hidden;
            position: relative;
        }

        .toast.success {
            background-color: #4CAF50;
        }

        .toast.warning {
            background-color: #ff9800;
        }

        .toast.error {
            background-color: #f44336;
        }

        .toast.info {
            background-color: #2196F3;
        }

        .toast .close-btn {
            background: transparent;
            border: none;
            color: white;
            font-size: 16px;
            cursor: pointer;
            margin-left: 10px;
        }

        .toast .progress-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 3px;
            width: 100%;
            background-color: rgba(255, 255, 255, 0.7);
            animation: progress 3s linear;
        }

        @keyframes slide-in {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes fade-out {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }

        @keyframes progress {
            from {
                width: 100%;
            }
            to {
                width: 0%;
            }
        }

        h1 {
            color: #333;
            margin-bottom: 30px;
        }
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background-color: var(--dark-bg);
      color: var(--text-primary);
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      padding: 0;
      margin: 0;
      line-height: 1.6;
      overflow: hidden;
    }

    .header {
      padding: 8px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      background-color: rgba(26, 26, 37, 0.8);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      position: sticky;
      top: 0;
      z-index: 10;
    }

    .editor-title {
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .gradient-text {
      font-size: 1.5rem;
      font-weight: 700;
      background: linear-gradient(135deg, #6c5ce7, #00cec9);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      white-space: nowrap;
    }

    .file-info {
      display: flex;
      gap: 15px;
      font-size: 13px;
      color: var(--text-secondary);
      align-items: center;
      background-color: rgba(0, 0, 0, 0.2);
      padding: 4px 12px;
      border-radius: 16px;
    }

    #controls {
      width: 100%;
      background-color: rgba(26, 26, 37, 0.95);
      padding: 8px 16px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }

    .control-groups {
      display: flex;
      justify-content: space-between;
      gap: 10px;
    }

    .control-group {
      display: flex;
      gap: 8px;
    }

    button {
      padding: 8px 12px;
      font-size: 12px;
      font-weight: 500;
      border-radius: 8px;
      border: none;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 6px;
      letter-spacing: 0.5px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
    }

    button:active {
      transform: translateY(0);
    }

    .file-btn {
      background: linear-gradient(135deg, #6c5ce7, #5f27cd);
      color: white;
    }

    .run-btn {
      background: linear-gradient(135deg, #00b894, #20bf6b);
      color: white;
    }

    .tool-btn {
      background: linear-gradient(135deg, #fdcb6e, #fab1a0);
      color: #2d3436;
    }

    .clear-btn {
      background: linear-gradient(135deg, #ff7675, #d63031);
      color: white;
    }

    .container {
      display: flex;
      height: calc(100vh - 115px);
      width: 100%;
    }

    #editor {
      flex: 1;
      height: 100%;
      overflow: hidden;
 
      position: relative;
      border-right: 1px solid rgba(255, 255, 255, 0.05);
    }

    .output-container {
     width: 35%;
      max-width: 500px;
      min-width: 300px;
      height: 100%;
      display: flex;
      flex-direction: column;
      position: relative;
      background-color: var(--card-bg);
    }

    .output-header {
      padding: 8px 16px;
      background-color: rgba(0, 0, 0, 0.2);
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .output-header h4 {
      margin: 0;
      font-size: 14px;
      font-weight: 600;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .output-actions {
      display: flex;
      gap: 10px;
    }

    .output-section {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
      font-size: 14px;
    }

    pre {
      white-space: pre-wrap;
      font-family: 'Fira Code', 'Cascadia Code', monospace;
      line-height: 1.6;
    }

    .resize-handle {
      width: 6px;
      height: 100%;
      background-color: rgba(255, 255, 255, 0.05);
      cursor: col-resize;
      transition: background-color 0.2s;
    }

    .resize-handle:hover {
      background-color: rgba(108, 92, 231, 0.5);
    }

    @media (max-width: 992px) {
      .container {
        flex-direction: column;
        height: auto;
      }

      #editor {
        height: 60vh;
        min-height: 400px;
      }

      .output-container {
        width: 100%;
        max-width: none;
        height: 40vh;
        min-height: 200px;
      }

      .resize-handle {
        display: none;
      }

      .header {
        flex-direction: column;
        align-items: flex-start;
        gap: 10px;
        padding-bottom: 12px;
      }

      .control-groups {
        flex-direction: column;
        width: 100%;
      }

      .control-group {
        flex-wrap: wrap;
      }
    }

    /* Compact design for small screens */
    @media (max-width: 768px) {
      .gradient-text {
        font-size: 1.2rem;
      }

      button {
        padding: 6px 10px;
        font-size: 11px;
      }
    }
  </style>
</head>

<body>
  <!-- Compact header with title and file info -->
  <div class="header">
    <div class="editor-title">
      <span class="gradient-text">Online The JavaScript Editor</span>
      <div class="file-info">
        <span>File: <strong id="fileName">No file opened</strong></span>
        <span>Status: <strong id="fileStatus">-</strong></span>
      </div>
    </div>
  </div>

  <!-- Better organized controls -->
  <div id="controls">
    <div class="control-groups">
      <div class="control-group">
        <!-- <button id="newFileBtn" class="file-btn">üìÑ New</button> -->
        <button id="openFileBtn" class="file-btn">üìÇ Open</button>
        <button id="saveFileBtn" class="file-btn"> üíæ Save</button>
    
      </div>
      
    
      
      <div class="control-group">
    
        <button id="interView" class="tool-btn">üìö Interview</button>
      </div>
    </div>
  </div>
  <div id="toast-container"></div>
  <!-- Main container with resizable panels -->
  <div class="container">
    <!-- Editor area (maximized space) -->
    <div id="editor"></div>
    
    <!-- Resizable handle -->
    <div class="resize-handle" id="resizeHandle"></div>
    
    <!-- Console output (more compact) -->
    <div class="output-container">
      <div class="output-header">
        <h4>Console Output</h4>
    
        <div class="control-group">
          <button id="clear" class="clear-btn" style="padding: 4px 8px; font-size: 11px;">üßπ Clear</button>
          <button id="run" class="run-btn">‚ñ∂Ô∏è Run</button>
          <button id="format" class="tool-btn">üîß Format</button>
          <!-- <button id="clear" class="clear-btn">üßπ Clear</button> -->
        </div>
      </div>
      <div class="output-section">
        <pre id="output"></pre>
      </div>
    </div>
  </div>
<script>
  let editor = null;
  let currentFileHandle = null;
let fileContentModified = false;
let lastSavedContent = '';

require.config({
  paths: {
    vs: "https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.43.0/min/vs"
  }
});

require(["vs/editor/editor.main"], function() {
  // Define custom editor theme
  monaco.editor.defineTheme('sunilTheme', {
    base: 'vs-dark',
    inherit: true,
    rules: [
      { token: 'comment', foreground: '6A9955', fontStyle: 'italic' },
      { token: 'keyword', foreground: '569CD6', fontStyle: 'bold' },
      { token: 'string', foreground: 'CE9178' },
      { token: 'number', foreground: 'B5CEA8' },
      { token: 'operator', foreground: 'D4D4D4' }
    ],
    colors: {
      'editor.background': '#1E1E1E',
      'editor.foreground': '#D4D4D4',
      'editorCursor.foreground': '#AEAFAD',
      'editor.lineHighlightBackground': '#2D2D30',
      'editorLineNumber.foreground': '#858585',
      'editor.selectionBackground': '#264F78',
      'editor.inactiveSelectionBackground': '#3A3D41'
    }
  });

  monaco.editor.defineTheme('sunilDarkPro', {
  base: 'vs-dark',
  inherit: true,
  rules: [
    // Basic syntax highlighting with vibrant colors
    { token: 'comment', foreground: '6A9955', fontStyle: 'italic' },
    { token: 'keyword', foreground: 'C586C0', fontStyle: 'bold' },
    { token: 'string', foreground: 'CE9178' },
    { token: 'number', foreground: 'B5CEA8' },
    { token: 'operator', foreground: 'D4D4D4' },
    
    // Enhanced JavaScript/TypeScript tokens
    { token: 'type', foreground: '4EC9B0' },
    { token: 'function', foreground: 'DCDCAA' },
    { token: 'variable', foreground: '9CDCFE' },
    { token: 'variable.parameter', foreground: '9CDCFE' },
    { token: 'variable.predefined', foreground: '4FC1FF' },
    { token: 'constant', foreground: '569CD6' },
    { token: 'class', foreground: '4EC9B0', fontStyle: 'bold' },
    { token: 'interface', foreground: '4EC9B0' },
    { token: 'namespace', foreground: '569CD6' },
    
    // Special tokens
    { token: 'regexp', foreground: 'D16969' },
    { token: 'meta', foreground: 'D4D4D4' },
    { token: 'tag', foreground: '569CD6' },
    { token: 'tag.attribute.name', foreground: '9CDCFE' },
    { token: 'attribute.name', foreground: '9CDCFE' },
    { token: 'attribute.value', foreground: 'CE9178' },
    
    // JSON specific
    { token: 'string.key', foreground: '9CDCFE' },
    { token: 'string.value', foreground: 'CE9178' },
    
    // HTML specific
    { token: 'delimiter.html', foreground: '808080' },
    { token: 'tag.html', foreground: '569CD6' },
    
    // CSS specific
    { token: 'attribute.name.css', foreground: 'D7BA7D' },
    { token: 'attribute.value.css', foreground: 'CE9178' }
  ],
  colors: {
    // Editor canvas
    'editor.background': '#1E1E2E',            // Slightly blue-tinted dark background
    'editor.foreground': '#F8F8F2',            // Bright text for contrast
    
    // Selection and highlights
    'editor.selectionBackground': '#264F78',   // Blue selection
    'editor.selectionHighlightBackground': '#2D2D4A',
    'editor.inactiveSelectionBackground': '#3A3D41',
    
    // Editor widgets
    'editorWidget.background': '#252537',
    'editorWidget.border': '#454545',
    'editorSuggestWidget.background': '#252537',
    'editorSuggestWidget.border': '#454545',
    'editorSuggestWidget.foreground': '#D4D4D4',
    'editorSuggestWidget.highlightForeground': '#18A3FF',
    'editorSuggestWidget.selectedBackground': '#062F4A',
    
    // Cursor and line numbers
    'editorCursor.foreground': '#F8F8F2',
    'editorLineNumber.foreground': '#858585',
    'editorLineNumber.activeForeground': '#C6C6C6',
    
    // Current line highlight
    'editor.lineHighlightBackground': '#2D2D45',
    'editor.lineHighlightBorder': '#282840',
    
    // Gutter
    'editorGutter.background': '#1E1E2E',
    
    // Bracket matches
    'editorBracketMatch.background': '#0D3A58',
    'editorBracketMatch.border': '#216694',
    
    // Overview ruler
    'editorOverviewRuler.border': '#7F7F7F4D',
    'editorOverviewRuler.findMatchForeground': '#F8C55499',
    'editorOverviewRuler.rangeHighlightForeground': '#007ACC99',
    'editorOverviewRuler.selectionHighlightForeground': '#A0A0A0CC',
    'editorOverviewRuler.wordHighlightForeground': '#A0A0A0CC',
    'editorOverviewRuler.wordHighlightStrongForeground': '#C0A0C0CC',
    
    // Scrollbar
    'scrollbarSlider.activeBackground': '#6F6F9380',
    'scrollbarSlider.background': '#48485E40',
    'scrollbarSlider.hoverBackground': '#5A5A7A60'
  }
});


  var editor = monaco.editor.create(document.getElementById("editor"), {
    
    language: "javascript",
    theme: "sunilDarkPro", // Use our new custom theme
    automaticLayout: true,
    minimap: {
      enabled: true,
      renderCharacters: false,
      showSlider: "always",
      maxColumn: 80
    },
    scrollBeyondLastLine: true,
    fontFamily: "'Fira Code', 'Consolas', monospace",
    fontLigatures: true, // Enable font ligatures
    fontSize: 14,
    lineHeight: 22,
    lineNumbers: "on",
    renderLineHighlight: "all",
    roundedSelection: true,
    cursorBlinking: "smooth",
    cursorSmoothCaretAnimation: true,
    smoothScrolling: true,
    scrollbar: {
      verticalScrollbarSize: 10,
      horizontalScrollbarSize: 10,
      vertical: "visible",
      horizontal: "visible",
      verticalHasArrows: false,
      horizontalHasArrows: false,
      useShadows: true
    },
    snippetSuggestions: "top",
    wordWrap: "on",
    wordWrapColumn: 80,
    wrappingIndent: "same",
    autoIndent: "full",
    formatOnPaste: true,
    formatOnType: true,
    renderWhitespace: "selection",
    renderControlCharacters: true,
    bracketPairColorization: {
      enabled: true
    },
    folding: true,
    glyphMargin: true,
    contextmenu: true,
    codeLens: true,
    colorDecorators: true,
    suggest: {
      filterGraceful: true,
      showIcons: true,
      maxVisibleSuggestions: 12,
      preview: true,
      snippetsPreventQuickSuggestions: false
    },
    parameterHints: {
      enabled: true,
      cycle: true
    }
  });


  function debounce(func, wait) {
  let timeout;
  return function() {
    const context = this;
    const args = arguments;
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      func.apply(context, args);
    }, wait);
  };
}

// Save code to localStorage and run it, with debouncing
const saveAndRunCode = debounce(() => {
  
}, 1000); // 1 second delay

// Add the event listener with debounced function
editor.onDidChangeModelContent(() => {
  localStorage.setItem("userCode", editor.getValue());
  
});

  // Load saved code
  editor.setValue(localStorage.getItem("userCode") || `console.log("Best of luck with your learning journey! üöÄ Keep coding and keep growing! üòä")`);

  const outputElement = document.getElementById("output");

  function loadQuestionPage() {
    window.location.href = "questions.html";
  }

 

  function runCode() {
  const code = editor.getValue();
  outputElement.innerText = "";
  
  let outputBuffer = "";
  const flushOutput = () => {
    outputElement.innerHTML += outputBuffer;
    outputBuffer = "";
  };
  
  let flushTimer = null;
  const startFlushTimer = () => {
    flushTimer = setInterval(flushOutput, 100);
  };
  
  const stopFlushTimer = () => {
    if (flushTimer) {
      clearInterval(flushTimer);
      flushTimer = null;
    }
  };
  
  // Save original console methods
  const originalConsole = {
    log: console.log,
    error: console.error,
    warn: console.warn,
    info: console.info,
    dir: console.dir
  };
  
  // Track displayed errors to prevent duplicates
  const displayedErrors = new Set();
  
  // Helper function to format property values
  function formatProperty(key, value, depth) {
    const indent = '&nbsp;'.repeat(depth * 4);
    const type = typeof value;
    let displayValue = '';
    
    if (value === null) {
      displayValue = '<span style="color: #a0a0a0;">null</span>';
    } else if (value === undefined) {
      displayValue = '<span style="color: #a0a0a0;">undefined</span>';
    } else if (type === 'string') {
      displayValue = `<span style="color: #c41a16;">"${value}"</span>`;
    } else if (type === 'number') {
      displayValue = `<span style="color: #1c00cf;">${value}</span>`;
    } else if (type === 'boolean') {
      displayValue = `<span style="color: #aa0d91;">${value}</span>`;
    } else if (type === 'function') {
      displayValue = `<span style="color: #5c2699;">∆í ${value.name || '(anonymous)'}()</span>`;
    } else if (Array.isArray(value)) {
      displayValue = `<span style="color: #5c2699;">Array(${value.length})</span>`;
    } else if (value instanceof Date) {
      displayValue = `<span style="color: #0b7dda;">Date: ${value.toString()}</span>`;
    } else if (type === 'object') {
      displayValue = `<span style="color: #5c2699;">${value.constructor ? value.constructor.name : 'Object'}</span>`;
    } else {
      displayValue = `<span>${String(value)}</span>`;
    }
    
    return `<div style="padding-left: ${depth * 4}px;">${indent}${key}: ${displayValue}</div>`;
  }

  // Display formatted error with deduplication
  function displayError(error) {
    const errorName = error.name || 'Error';
    const errorMessage = error.message || String(error);
    
    // Create a unique key for this error to prevent duplicates
    const errorKey = `${errorName}:${errorMessage}`;
    
    // Check if we've already displayed this error
    if (displayedErrors.has(errorKey)) {
      return;
    }
    
    // Mark this error as displayed
    displayedErrors.add(errorKey);
    
    let stackTrace = '';
    
    if (error.stack) {
      // Format the stack trace to be more readable
      stackTrace = error.stack
        .split('\n')
        .map(line => line.trim())
        .join('\n');
    }
    
    outputBuffer += `<div style="background-color: #fff0f0; border-left: 4px solid #ff5252; padding: 12px; margin: 10px 0; border-radius: 4px; font-family: monospace;">
      <div style="color: #d32f2f; font-weight: bold; font-size: 16px; margin-bottom: 8px;">${errorName}</div>
      <div style="color: #333; margin-bottom: 10px;">${errorMessage}</div>
      ${stackTrace ? `<pre style="margin-top: 10px; font-size: 14px; color: #666; background: #f8f8f8; padding: 8px; border-radius: 4px; overflow-x: auto;">${stackTrace}</pre>` : ''}
    </div>`;
    
    flushOutput();
  }

  // Override console methods
  console.log = function(...args) {
    const formattedArgs = args.map(arg => {
      if (arg === undefined) return "undefined";
      if (arg === null) return "null";
      if (typeof arg === 'object') {
        try { return JSON.stringify(arg); } 
        catch (e) { return String(arg); }
      }
      return String(arg);
    });
    outputBuffer += `<span style="color: #00b894;">${formattedArgs.join(" ")}</span>\n`;
    if (!flushTimer) startFlushTimer();
  };
  
  console.error = function(...args) {
    outputBuffer += `<span style="color: #ff6b6b;">Error: ${args.join(" ")}</span>\n`;
    if (!flushTimer) startFlushTimer();
  };
  
  console.warn = function(...args) {
    outputBuffer += `<span style="color: #feca57;">Warning: ${args.join(" ")}</span>\n`;
    if (!flushTimer) startFlushTimer();
  };
  
  console.info = function(...args) {
    outputBuffer += `<span style="color: #54a0ff;">Info: ${args.join(" ")}</span>\n`;
    if (!flushTimer) startFlushTimer();
  };
  
  console.dir = function(obj) {
    if (obj === null || obj === undefined) {
      outputBuffer += `<span style="color: #a0a0a0;">${obj === null ? 'null' : 'undefined'}</span>\n`;
      if (!flushTimer) startFlushTimer();
      return;
    }

    let html = `<div style="font-family: monospace; color: #333; padding: 5px; border: 1px solid #ddd; border-radius: 4px; margin: 5px 0; background-color: #f8f8f8;">`;
    
    // Object type header
    const objType = obj.constructor ? obj.constructor.name : 'Object';
    html += `<div style="font-weight: bold; color: #444; margin-bottom: 5px;">${objType}</div>`;

    // Process own properties
    const ownProps = Object.getOwnPropertyNames(obj).sort();
    if (ownProps.length > 0) {
      html += `<div style="margin-bottom: 8px;">`;
      ownProps.forEach(prop => {
        try {
          const descriptor = Object.getOwnPropertyDescriptor(obj, prop);
          if (descriptor && (descriptor.get || descriptor.set)) {
            html += `<div>${prop}: <span style="color: #5c2699;">${descriptor.get ? 'getter' : ''}${descriptor.get && descriptor.set ? ' / ' : ''}${descriptor.set ? 'setter' : ''}</span></div>`;
          } else {
            html += formatProperty(prop, obj[prop], 0);
          }
        } catch (e) {
          html += `<div>${prop}: <span style="color: #ff6b6b;">(access denied)</span></div>`;
        }
      });
      html += `</div>`;
    }

    // Process prototype chain recursively
    let proto = Object.getPrototypeOf(obj);
    let depth = 0;
    const maxDepth = 5;
    
    while (proto && proto !== null && depth < maxDepth) {
      html += `<div style="margin-top: 8px; border-top: 1px solid #eee; padding-top: 8px;">`;
      html += `<div style="color: #888; font-style: italic;">[[Prototype]]: ${proto.constructor ? proto.constructor.name : 'Object'}</div>`;
      
      const protoProps = Object.getOwnPropertyNames(proto).sort();
      if (protoProps.length > 0) {
        protoProps.forEach(prop => {
          try {
            const descriptor = Object.getOwnPropertyDescriptor(proto, prop);
            if (descriptor && (descriptor.get || descriptor.set)) {
              html += `<div style="padding-left: ${depth * 15}px;">${prop}: <span style="color: #5c2699;">${descriptor.get ? 'getter' : ''}${descriptor.get && descriptor.set ? ' / ' : ''}${descriptor.set ? 'setter' : ''}</span></div>`;
            } else {
              html += formatProperty(prop, proto[prop], depth + 1);
            }
          } catch (e) {
            html += `<div style="padding-left: ${depth * 15}px;">${prop}: <span style="color: #ff6b6b;">(access denied)</span></div>`;
          }
        });
      } else {
        html += `<div style="padding-left: ${depth * 15}px; color: #888;">(no enumerable properties)</div>`;
      }
      
      html += `</div>`;
      proto = Object.getPrototypeOf(proto);
      depth++;
    }

    html += `</div>`;
    outputBuffer += html;
    if (!flushTimer) startFlushTimer();
  };

  // Save original error handlers
  const originalOnError = window.onerror;
  const originalOnUnhandledRejection = window.onunhandledrejection;

  // Set up error handlers
  window.onerror = function(message, source, lineno, colno, error) {
    if (error) {
      displayError(error);
    } else {
      displayError({ name: "Error", message: message });
    }
    return true; // Prevent default error handling
  };

  window.onunhandledrejection = function(event) {
    displayError(event.reason);
    return true; // Prevent default error handling
  };
  
  try {
    // Prepare environment for code execution
    let loopStartTime = Date.now();
    let iterationCount = 0;
    const maxIterationTime = 5000;
    
    // Use Function constructor approach instead of iframe for simplicity
    // This focuses on properly handling and deduplicating errors
    const executeUserCode = function() {
      try {
        // Add monitoring for loops
        let monitoredCode = code.replace(/for\s*\([^)]*\)\s*{/g, match => {
          return `${match} 
            iterationCount++; 
            if (iterationCount % 1000 === 0) { 
              if (Date.now() - loopStartTime > maxIterationTime) {
                throw new Error("Loop execution time exceeded safety limit");
              }
              flushOutput();
            }`;
        });
        
        monitoredCode = monitoredCode.replace(/while\s*\([^)]*\)\s*{/g, match => {
          return `${match} 
            iterationCount++; 
            if (iterationCount % 1000 === 0) { 
              if (Date.now() - loopStartTime > maxIterationTime) {
                throw new Error("Loop execution time exceeded safety limit");
              }
              flushOutput();
            }`;
        });
        
        // Create a function with proper scoping for variables
        const execFunc = new Function(
          'console', 'iterationCount', 'loopStartTime', 'maxIterationTime', 'flushOutput',
          `"use strict";
           return (function() { 
             ${monitoredCode} 
           })();`
        );
        
        const result = execFunc(console, iterationCount, loopStartTime, maxIterationTime, flushOutput);
        
        if (result instanceof Promise) {
          result
            .then(value => {
              if (value !== undefined) {
                console.log("Promise resolved:", value);
              }
              flushOutput();
            })
            .catch(error => {
              displayError(error);
            })
            .finally(() => {
              stopFlushTimer();
            });
        } else {
          if (result !== undefined) {
            console.log("Return value:", result);
          }
        }
        
        return result;
      } catch (error) {
        displayError(error);
        return null;
      }
    };
    
    // Execute the code
    executeUserCode();
    
  } catch (error) {
    displayError(error);
  } finally {
    // Clean up after execution
    flushOutput();
    stopFlushTimer();
    
    // Restore original console methods and error handlers
    setTimeout(() => {
      console.log = originalConsole.log;
      console.error = originalConsole.error;
      console.warn = originalConsole.warn;
      console.info = originalConsole.info;
      console.dir = originalConsole.dir;
      window.onerror = originalOnError;
      window.onunhandledrejection = originalOnUnhandledRejection;
    }, 11000);
  }
}

  document.getElementById("clear").addEventListener("click", function() {

    outputElement.innerText = "";
  });

  document.getElementById("run").addEventListener("click", runCode);
  document.getElementById("interView").addEventListener("click", loadQuestionPage);
  document.getElementById("format").addEventListener("click", formatCode);
  document.getElementById('openFileBtn').addEventListener('click', openFile);

  document.getElementById('saveFileBtn').addEventListener('click', saveFile);

  editor.addEventListener('input', () => {
    fileContentModified = true;
    document.getElementById('fileStatus').textContent = 'Modified';
  });
  

// Handle editor changes
editor.on('change', function() {
  fileContentModified = true;
  const statusElement = document.getElementById('fileStatus');
  if (statusElement) {
    statusElement.textContent = 'Modified';
    statusElement.style.color = 'orange';
  }
});
// Global variables for file handling


// Initialize on page load
window.addEventListener('DOMContentLoaded', async () => {
  // Try to restore the last opened file
  const restored = await tryRestoreLastFile();
  
  if (!restored) {
    // Check if there's content in localStorage
    const savedContent = localStorage.getItem('lastFileContent');
    const fileName = localStorage.getItem('lastOpenedFileName');
    
    if (savedContent) {
      // Restore content from localStorage
      editor.setValue(savedContent);
      lastSavedContent = savedContent;
      
      // Update UI
      document.getElementById('fileName').textContent = fileName || 'Restored File';
      document.getElementById('fileStatus').textContent = 'Restored (No Handle)';
      document.getElementById('fileStatus').style.color = 'orange';
    } else {
      // If no file was restored, set initial state
      document.getElementById('fileName').textContent = 'Untitled';
      document.getElementById('fileStatus').textContent = 'New';
    }
  }
  
  // Add beforeunload event listener to warn about unsaved changes
  window.addEventListener('beforeunload', function(e) {
    if (fileContentModified) {
      // Save current content to localStorage before closing
      localStorage.setItem('lastFileContent', editor.getValue());
      
      // Show warning about unsaved changes
      e.preventDefault();
      e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
      return e.returnValue;
    }
  });
});

// Handle editor changes
editor.on('change', function() {
  const currentContent = editor.getValue();
  
  // Only mark as modified if content has changed from last saved state
  if (currentContent !== lastSavedContent) {
    fileContentModified = true;
    const statusElement = document.getElementById('fileStatus');
    if (statusElement) {
      statusElement.textContent = 'Modified';
      statusElement.style.color = 'orange';
    }
    
    // Save content to localStorage for recovery
    localStorage.setItem('lastFileContent', currentContent);
  } else {
    fileContentModified = false;
    const statusElement = document.getElementById('fileStatus');
    if (statusElement) {
      statusElement.textContent = currentFileHandle ? 'Saved' : 'Unchanged';
      statusElement.style.color = 'green';
    }
  }
});

// Function to open a file
async function openFile() {
  try {
    // Check if the File System Access API is supported
    if (!('showOpenFilePicker' in window)) {
      showToast('Please use Chrome or Edge - this feature requires File System Access API support.', 'warning');
      return;
    }

    // Show file picker to let user select a JavaScript file
    const [fileHandle] = await window.showOpenFilePicker({
      types: [
        {
          description: 'JavaScript Files',
          accept: {
            'text/javascript': ['.js'],
          },
        },
      ],
      multiple: false,
    });
    
    // Store the file handle in a global variable
    currentFileHandle = fileHandle;
    
    // Request permission to remember this file
    if (fileHandle.requestPermission) {
      const permissionState = await fileHandle.requestPermission({ mode: 'readwrite' });
      if (permissionState === 'granted') {
        // Store a reference to this file
        try {
          // We can't store the file handle directly, but we can store its id
          // to attempt to retrieve it later
          const fileId = await fileHandle.getUniqueId();
          localStorage.setItem('lastOpenedFileId', fileId);
          localStorage.setItem('lastOpenedFileName', fileHandle.name || 'unknown.js');
        } catch (e) {
          console.warn('Could not store file reference:', e);
        }
      }
    }
    
    // Get file data
    const file = await fileHandle.getFile();
    const content = await file.text();
    
    // Update editor with file content
    editor.setValue(content);
    lastSavedContent = content;
    
    // Store content in localStorage for recovery after reload
    localStorage.setItem('lastFileContent', content);
    
    // Update UI to show the current file
    document.getElementById('fileName').textContent = file.name;
    document.getElementById('fileStatus').textContent = 'Opened';
    document.getElementById('fileStatus').style.color = 'green';
    fileContentModified = false;
    
    // Apply code formatting if available
    if (typeof formatCode === 'function') {
      formatCode();
    }
  } catch (error) {
    console.error('Error opening file:', error);
    showToast(`Error opening file: ${error.message}`, "error");
    
  }
}


function showToast(message, type) {

            const toastContainer = document.getElementById('toast-container');
            
            // Create toast element
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            
            // Create message text
            const messageText = document.createElement('span');
            messageText.innerText = message;
            
            // Create close button
            const closeButton = document.createElement('button');
            closeButton.innerText = '√ó';
            closeButton.className = 'close-btn';
            closeButton.onclick = function() {
                toastContainer.removeChild(toast);
            };
            
            // Create progress bar
            const progressBar = document.createElement('div');
            progressBar.className = 'progress-bar';
            
            // Assemble toast
            toast.appendChild(messageText);
            toast.appendChild(closeButton);
            toast.appendChild(progressBar);
            
            // Add to container
            toastContainer.appendChild(toast);
            
            // Auto remove after 3 seconds
            setTimeout(function() {
                if (toastContainer.contains(toast)) {
                    toastContainer.removeChild(toast);
                }
            }, 3000);
        }
// Function to save the current file
async function saveFile() {
  console.log("Saving file, currentFileHandle:", currentFileHandle);
  
  if (!currentFileHandle) {
    return await saveFileAs();
  }
  
  try {
    // Check if we have permission to write to this file
    if (currentFileHandle.requestPermission) {
      const permissionState = await currentFileHandle.requestPermission({ mode: 'readwrite' });
      if (permissionState !== 'granted') {
        throw new Error('Permission to write to file was denied');
      }
    }
    
    // Format code before saving (if formatCode exists)
    if (typeof formatCode === 'function') {
      formatCode();
    }

    // Create a FileSystemWritableFileStream to write to
    const writable = await currentFileHandle.createWritable();
    
    // Get the editor content
    const content = editor.getValue();
    console.log("Content to save:", content.substring(0, 50) + "...");
    
    // Write the contents of the editor to the file
    await writable.write(content);
    
    // Close the file and write the contents to disk
    await writable.close();
    
    // Update last saved content
    lastSavedContent = content;
    
    // Store content in localStorage for recovery after reload
    localStorage.setItem('lastFileContent', content);
    
    // Update UI
    const statusElement = document.getElementById('fileStatus');
    if (statusElement) {
      statusElement.textContent = 'Saved';
      statusElement.style.color = 'green';
    }
    
    fileContentModified = false;
    console.log('File saved successfully');
    
    return true;
  } catch (error) {
    console.error('Error saving file:', error);

    showToast(`Error saving file: ${error.message}`, "error");
    const statusElement = document.getElementById('fileStatus');
    if (statusElement) {
      statusElement.textContent = 'Error saving';
      statusElement.style.color = 'red';
    }
    
    return false;
  }
}

// Function to save as a new file
async function saveFileAs() {
  try {
    // Check if the File System Access API is supported
    if (!('showSaveFilePicker' in window)) {
     
      showToast('Please use Chrome or Edge - this feature requires File System Access API support.', 'warning');
      return false;
    }
    
    const currentFileName = currentFileHandle ? currentFileHandle.name : 
                           localStorage.getItem('lastOpenedFileName') || 'script.js';
    
    // Show file picker to let user select where to save the file
    const fileHandle = await window.showSaveFilePicker({
      types: [
        {
          description: 'JavaScript Files',
          accept: {
            'text/javascript': ['.js'],
          },
        },
      ],
      suggestedName: currentFileName
    });
    
    // Update the current file handle
    currentFileHandle = fileHandle;
    
    // Request permission to remember this file
    if (fileHandle.requestPermission) {
      const permissionState = await fileHandle.requestPermission({ mode: 'readwrite' });
      if (permissionState === 'granted') {
        try {
          const fileId = await fileHandle.getUniqueId();
          localStorage.setItem('lastOpenedFileId', fileId);
          localStorage.setItem('lastOpenedFileName', fileHandle.name || 'unknown.js');
        } catch (e) {
          console.warn('Could not store file reference:', e);
        }
      }
    }
    
    // Update UI to show the current file
    const file = await fileHandle.getFile();
    document.getElementById('fileName').textContent = file.name;
    
    // Save the file using the new handle
    return await saveFile();
  } catch (error) {
    console.error('Error in Save As:', error);
    showToast(`Error saving file: ${error.message}`, "error");
  
    return false;
  }
}

// Function to try to restore the last opened file
async function tryRestoreLastFile() {
  try {
    // First try to get the file handle by ID if the API is available
    if ('getFileHandles' in window) {
      const fileId = localStorage.getItem('lastOpenedFileId');
      if (fileId) {
        try {
          const fileHandles = await window.getFileHandles([fileId]);
          if (fileHandles && fileHandles.length > 0) {
            currentFileHandle = fileHandles[0];
            
            // Get file data
            const file = await currentFileHandle.getFile();
            const content = await file.text();
            
            // Update editor with file content
            editor.setValue(content);
            lastSavedContent = content;
            
            // Store content in localStorage for recovery
            localStorage.setItem('lastFileContent', content);
            
            // Update UI
            document.getElementById('fileName').textContent = file.name;
            document.getElementById('fileStatus').textContent = 'Restored';
            document.getElementById('fileStatus').style.color = 'green';
            fileContentModified = false;
            
            return true;
          }
        } catch (e) {
          console.warn('Could not restore file by ID:', e);
        }
      }
    }
    
    return false;
  } catch (error) {
    console.error('Error restoring file:', error);
    return false;
  }
}

// Function to create a new file (clears the editor)
function newFile() {
  // Prompt to save if there are unsaved changes
  if (fileContentModified) {
    if (!confirm('You have unsaved changes. Create a new file anyway?')) {
      return;
    }
  }
  
  // Clear the editor
  editor.setValue('');
  lastSavedContent = '';
  
  // Clear the current file handle
  currentFileHandle = null;
  
  // Update localStorage
  localStorage.removeItem('lastOpenedFileId');
  localStorage.setItem('lastOpenedFileName', 'Untitled');
  localStorage.setItem('lastFileContent', '');
  
  // Update UI
  document.getElementById('fileName').textContent = 'Untitled';
  document.getElementById('fileStatus').textContent = 'New';
  document.getElementById('fileStatus').style.color = 'black';
  fileContentModified = false;
}

// Function to recover unsaved content after a crash/reload
function recoverUnsavedContent() {
  const savedContent = localStorage.getItem('lastFileContent');
  if (savedContent && (!currentFileHandle || editor.getValue() !== savedContent)) {
    if (confirm('Unsaved content from your previous session was found. Do you want to recover it?')) {
      editor.setValue(savedContent);
      
      // Update UI
      const fileName = localStorage.getItem('lastOpenedFileName') || 'Recovered File';
      document.getElementById('fileName').textContent = fileName;
      document.getElementById('fileStatus').textContent = 'Recovered';
      document.getElementById('fileStatus').style.color = 'blue';
    }
  }
}

// Function to handle keyboard shortcuts
function handleKeyboardShortcuts(event) {
  // Ctrl+S or Cmd+S to save
  if ((event.ctrlKey || event.metaKey) && event.key === 's') {
    event.preventDefault();
    if (currentFileHandle) {
      saveFile();
    } else {
      saveFileAs();
    }
  }
  
  // Ctrl+O or Cmd+O to open
  if ((event.ctrlKey || event.metaKey) && event.key === 'o') {
    event.preventDefault();
    openFile();
  }
  
  // Ctrl+N or Cmd+N for new file
  if ((event.ctrlKey || event.metaKey) && event.key === 'n') {
    event.preventDefault();
    newFile();
  }
}

// Add event listener for keyboard shortcuts
document.addEventListener('keydown', handleKeyboardShortcuts);

// Call this function after a short delay to allow normal restore first
setTimeout(recoverUnsavedContent, 1000);

// Function to handle keyboard shortcuts
function handleKeyboardShortcuts(event) {
  // Ctrl+S or Cmd+S to save
  if ((event.ctrlKey || event.metaKey) && event.key === 's') {
    event.preventDefault();
    if (currentFileHandle) {
      saveFile();
    } else {
      saveFileAs();
    }
  }
  
  // Ctrl+O or Cmd+O to open
  if ((event.ctrlKey || event.metaKey) && event.key === 'o') {
    event.preventDefault();
    openFile();
  }
  
  // Ctrl+N or Cmd+N for new file
  if ((event.ctrlKey || event.metaKey) && event.key === 'n') {
    event.preventDefault();
    newFile();
  }
}

// Add event listener for keyboard shortcuts
document.addEventListener('keydown', handleKeyboardShortcuts);

// Initialize on page load
window.addEventListener('DOMContentLoaded', async () => {
  // Try to restore the last opened file
  const restored = await tryRestoreLastFile();
  
  if (!restored) {
    // If no file was restored, set initial state
    document.getElementById('fileName').textContent = 'Untitled';
    document.getElementById('fileStatus').textContent = 'New';
  }
  
  // Additional initialization can go here
});
// Call this when the page loads
document.addEventListener('DOMContentLoaded', async () => {
  // Try to restore the last opened file
  const restored = await tryRestoreLastFile();
  if (!restored) {
    console.log('No previously opened file found or permission denied');
  }
  
  // Other initialization code...
});
// Call this when the page loads
document.addEventListener('DOMContentLoaded', async () => {
  // Try to restore the last opened file
  const restored = await tryRestoreLastFile();
  if (!restored) {
    console.log('No previously opened file found or permission denied');
  }
  
  // Other initialization code...
});
  function formatCode() {
  try {
    // Get current code from editor
    const code = editor.getValue();
    if (!code.trim()) return;
    
    // Use js-beautify to format the code
    // js-beautify exposes this as window.js_beautify or window.beautify
    if (typeof window.js_beautify === 'undefined' && typeof window.beautify === 'undefined') {
      // If neither function exists, dynamically load js-beautify
      const script = document.createElement('script');
      script.src = 'https://cdnjs.cloudflare.com/ajax/libs/js-beautify/1.14.9/beautify.min.js';
      script.onload = function() {
        applyFormatting(code);
      };
      document.head.appendChild(script);
    } else {
      // Use the available function
      applyFormatting(code);
    }
  } catch (error) {
    outputElement.innerHTML = `<span style="color: #ff6b6b; font-style: italic;">‚ö†Ô∏è Formatting error: ${error.message}</span>\n`;
  }
}

// Apply formatting with available beautify function
function applyFormatting(code) {
  // Try different ways the function might be exposed
  const beautifyFn = window.js_beautify || window.beautify || window.jsbeautify;
  
  if (typeof beautifyFn === 'function') {
    const formattedCode = beautifyFn(code, {
      indent_size: 2,
      space_in_empty_paren: true,
      preserve_newlines: true,
      max_preserve_newlines: 2,
      wrap_line_length: 80,
      indent_with_tabs: false,
      end_with_newline: true,
      brace_style: "collapse,preserve-inline"
    });
    
    // Update editor with formatted code
    editor.setValue(formattedCode);
    
    // Show success message in output
    outputElement.innerHTML = `<span style="color: #00b894; font-style: italic;">‚úÖ Code formatted successfully!</span>\n`;
    
    // Clear message after 3 seconds
    setTimeout(() => {
      outputElement.innerHTML = "";
      runCode()
    }, 1000);
  } else {
    // Fallback to Monaco editor's built-in formatting
    monaco.editor.getEditors()[0].getAction('editor.action.formatDocument').run();
    outputElement.innerHTML = `<span style="color: #00b894; font-style: italic;">‚úÖ Code formatted using editor's built-in formatter</span>\n`;
    
    setTimeout(() => {
      outputElement.innerHTML = "";
      runCode()
    }, 1000);
  }
}

// Add a keyboard shortcut for formatting (Alt+Shift+F)
document.addEventListener('keydown', function(e) {
  // Alt+Shift+F
  if (e.altKey && e.shiftKey && e.key === 'F') {
    e.preventDefault();
    formatCode();
  }
});

  document.getElementById("fileInput").addEventListener("change", function(event) {
    const file = event.target.files[0];
    if (file && file.name.endsWith('.js')) {
      const reader = new FileReader();
      const mergeChoice = confirm("Do you want to merge with the existing code?\n\n‚úÖ OK: Merge\n‚ùå Cancel: Replace");

      reader.onload = function(e) {
        const editorvalue = editor.getValue() || ""
        const concatValue = mergeChoice ? `${editorvalue} \n ${e.target.result}` : `${e.target.result}` 
        editor.setValue(concatValue);
      };
      reader.readAsText(file);
      editor.onDidChangeModelContent(() => {
        localStorage.setItem("userCode", concatValue);
      });
    } else {
      showToast("Please select a valid JavaScript (.js) file.","error");
    }
  });
});

// Auto-completion
monaco.languages.typescript.javascriptDefaults.setCompilerOptions({
  target: monaco.languages.typescript.ScriptTarget.ES6,
  allowNonTsExtensions: true
});

monaco.languages.registerCompletionItemProvider("javascript", {
  provideCompletionItems: () => {
    return {
      suggestions: [
        {
          label: "log",
          kind: monaco.languages.CompletionItemKind.Function,
          insertText: 'console.log($1);',
          insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet
        }
      ]
    };
  }
});
</script>
</body>
</html>